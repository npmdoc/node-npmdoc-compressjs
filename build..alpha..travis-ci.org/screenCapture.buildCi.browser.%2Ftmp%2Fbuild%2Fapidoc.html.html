<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a>compressjs (v1.0.3)</a>
</h1>
<h4>pure JavaScript de/compression (bzip2, etc) for node.js, volo, and the browser.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs">module compressjs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.BitStream">
            function <span class="apidocSignatureSpan">compressjs.</span>BitStream
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Context1Model">
            function <span class="apidocSignatureSpan">compressjs.</span>Context1Model
            <span class="apidocSignatureSpan">(modelFactory, contextSize, alphabetSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DefSumModel">
            function <span class="apidocSignatureSpan">compressjs.</span>DefSumModel
            <span class="apidocSignatureSpan">(coder, size, isDecoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DeflateDistanceModel">
            function <span class="apidocSignatureSpan">compressjs.</span>DeflateDistanceModel
            <span class="apidocSignatureSpan">(size, extraStates, lgDistanceModelFactory, lengthBitsModelFactory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder">
            function <span class="apidocSignatureSpan">compressjs.</span>DummyRangeCoder
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.FenwickModel">
            function <span class="apidocSignatureSpan">compressjs.</span>FenwickModel
            <span class="apidocSignatureSpan">(coder, size, max_prob, increment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman">
            function <span class="apidocSignatureSpan">compressjs.</span>Huffman
            <span class="apidocSignatureSpan">(size, root, bitstream, max_weight)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.LogDistanceModel">
            function <span class="apidocSignatureSpan">compressjs.</span>LogDistanceModel
            <span class="apidocSignatureSpan">(size, extraStates, lgDistanceModelFactory, lengthBitsModelFactory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.MTFModel">
            function <span class="apidocSignatureSpan">compressjs.</span>MTFModel
            <span class="apidocSignatureSpan">(coder, size, max_prob, increment, betterEscape)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.NoModel">
            function <span class="apidocSignatureSpan">compressjs.</span>NoModel
            <span class="apidocSignatureSpan">(bitstream, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.PPM">
            function <span class="apidocSignatureSpan">compressjs.</span>PPM
            <span class="apidocSignatureSpan">(coder, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder">
            function <span class="apidocSignatureSpan">compressjs.</span>RangeCoder
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Stream">
            function <span class="apidocSignatureSpan">compressjs.</span>Stream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>BWT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>BWTC</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>BitStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>Bzip2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>Context1Model.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>DefSumModel.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>DeflateDistanceModel.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>Dmc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>DummyRangeCoder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>FenwickModel.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>Huffman.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>HuffmanAllocator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>LogDistanceModel.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>Lzjb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>LzjbR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>Lzp3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>MTFModel.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>NoModel.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>PPM.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>RangeCoder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>Simple</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>Stream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">compressjs.</span>Util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.BWT">module compressjs.BWT</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.BWT.bwtransform">
            function <span class="apidocSignatureSpan">compressjs.BWT.</span>bwtransform
            <span class="apidocSignatureSpan">(T, U, A, n, alphabetSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.BWT.bwtransform2">
            function <span class="apidocSignatureSpan">compressjs.BWT.</span>bwtransform2
            <span class="apidocSignatureSpan">(T, U, n, alphabetSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.BWT.suffixsort">
            function <span class="apidocSignatureSpan">compressjs.BWT.</span>suffixsort
            <span class="apidocSignatureSpan">(T, SA, n, alphabetSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.BWT.unbwtransform">
            function <span class="apidocSignatureSpan">compressjs.BWT.</span>unbwtransform
            <span class="apidocSignatureSpan">(T, U, LF, n, pidx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.BWTC">module compressjs.BWTC</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.BWTC.compressFile">
            function <span class="apidocSignatureSpan">compressjs.BWTC.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.BWTC.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.BWTC.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.BWTC.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.BitStream">module compressjs.BitStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.BitStream.BitStream">
            function <span class="apidocSignatureSpan">compressjs.</span>BitStream
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">compressjs.BitStream.</span>EOF</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.BitStream.prototype">module compressjs.BitStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.BitStream.prototype.readBits">
            function <span class="apidocSignatureSpan">compressjs.BitStream.prototype.</span>readBits
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.BitStream.prototype.writeBits">
            function <span class="apidocSignatureSpan">compressjs.BitStream.prototype.</span>writeBits
            <span class="apidocSignatureSpan">(n, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.Bzip2">module compressjs.Bzip2</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Bzip2.compressFile">
            function <span class="apidocSignatureSpan">compressjs.Bzip2.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Bzip2.decompressBlock">
            function <span class="apidocSignatureSpan">compressjs.Bzip2.</span>decompressBlock
            <span class="apidocSignatureSpan">(input, pos, output)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Bzip2.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.Bzip2.</span>decompressFile
            <span class="apidocSignatureSpan">(input, output, multistream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Bzip2.table">
            function <span class="apidocSignatureSpan">compressjs.Bzip2.</span>table
            <span class="apidocSignatureSpan">(input, callback, multistream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.Context1Model">module compressjs.Context1Model</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Context1Model.Context1Model">
            function <span class="apidocSignatureSpan">compressjs.</span>Context1Model
            <span class="apidocSignatureSpan">(modelFactory, contextSize, alphabetSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Context1Model.compressFile">
            function <span class="apidocSignatureSpan">compressjs.Context1Model.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Context1Model.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.Context1Model.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.Context1Model.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.Context1Model.prototype">module compressjs.Context1Model.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Context1Model.prototype.decode">
            function <span class="apidocSignatureSpan">compressjs.Context1Model.prototype.</span>decode
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Context1Model.prototype.encode">
            function <span class="apidocSignatureSpan">compressjs.Context1Model.prototype.</span>encode
            <span class="apidocSignatureSpan">(ch, context)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.DefSumModel">module compressjs.DefSumModel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DefSumModel.DefSumModel">
            function <span class="apidocSignatureSpan">compressjs.</span>DefSumModel
            <span class="apidocSignatureSpan">(coder, size, isDecoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DefSumModel.compressFile">
            function <span class="apidocSignatureSpan">compressjs.DefSumModel.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DefSumModel.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.DefSumModel.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DefSumModel.factory">
            function <span class="apidocSignatureSpan">compressjs.DefSumModel.</span>factory
            <span class="apidocSignatureSpan">(coder, isDecoder)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.DefSumModel.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.DefSumModel.prototype">module compressjs.DefSumModel.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DefSumModel.prototype._update">
            function <span class="apidocSignatureSpan">compressjs.DefSumModel.prototype.</span>_update
            <span class="apidocSignatureSpan">(symbol, isDecoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DefSumModel.prototype.decode">
            function <span class="apidocSignatureSpan">compressjs.DefSumModel.prototype.</span>decode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DefSumModel.prototype.encode">
            function <span class="apidocSignatureSpan">compressjs.DefSumModel.prototype.</span>encode
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.DeflateDistanceModel">module compressjs.DeflateDistanceModel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DeflateDistanceModel.DeflateDistanceModel">
            function <span class="apidocSignatureSpan">compressjs.</span>DeflateDistanceModel
            <span class="apidocSignatureSpan">(size, extraStates, lgDistanceModelFactory, lengthBitsModelFactory)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.DeflateDistanceModel.prototype">module compressjs.DeflateDistanceModel.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DeflateDistanceModel.prototype.decode">
            function <span class="apidocSignatureSpan">compressjs.DeflateDistanceModel.prototype.</span>decode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DeflateDistanceModel.prototype.encode">
            function <span class="apidocSignatureSpan">compressjs.DeflateDistanceModel.prototype.</span>encode
            <span class="apidocSignatureSpan">(distance)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.Dmc">module compressjs.Dmc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Dmc.compressFile">
            function <span class="apidocSignatureSpan">compressjs.Dmc.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Dmc.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.Dmc.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.Dmc.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.DummyRangeCoder">module compressjs.DummyRangeCoder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.DummyRangeCoder">
            function <span class="apidocSignatureSpan">compressjs.</span>DummyRangeCoder
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.DummyRangeCoder.prototype">module compressjs.DummyRangeCoder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype._read16">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>_read16
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype._read8">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>_read8
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype._write16">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>_write16
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype._write8">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>_write8
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype.decodeCulFreq">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>decodeCulFreq
            <span class="apidocSignatureSpan">(tot_f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype.decodeCulShift">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>decodeCulShift
            <span class="apidocSignatureSpan">(shift)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype.decodeFinish">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>decodeFinish
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype.decodeStart">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>decodeStart
            <span class="apidocSignatureSpan">(skipInitialRead)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype.decodeUpdate">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>decodeUpdate
            <span class="apidocSignatureSpan">(sy_f, lt_f, tot_f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype.encodeFinish">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>encodeFinish
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype.encodeFreq">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>encodeFreq
            <span class="apidocSignatureSpan">(sy_f, lt_f, tot_f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype.encodeShift">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>encodeShift
            <span class="apidocSignatureSpan">(sy_f, lt_f, shift)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.DummyRangeCoder.prototype.encodeStart">
            function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>encodeStart
            <span class="apidocSignatureSpan">(c, initlength)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.FenwickModel">module compressjs.FenwickModel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.FenwickModel.FenwickModel">
            function <span class="apidocSignatureSpan">compressjs.</span>FenwickModel
            <span class="apidocSignatureSpan">(coder, size, max_prob, increment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.FenwickModel.compressFile">
            function <span class="apidocSignatureSpan">compressjs.FenwickModel.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.FenwickModel.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.FenwickModel.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.FenwickModel.factory">
            function <span class="apidocSignatureSpan">compressjs.FenwickModel.</span>factory
            <span class="apidocSignatureSpan">(coder, max_prob, increment)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.FenwickModel.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.FenwickModel.prototype">module compressjs.FenwickModel.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.FenwickModel.prototype._decode">
            function <span class="apidocSignatureSpan">compressjs.FenwickModel.prototype.</span>_decode
            <span class="apidocSignatureSpan">(isEscape)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.FenwickModel.prototype._rescale">
            function <span class="apidocSignatureSpan">compressjs.FenwickModel.prototype.</span>_rescale
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.FenwickModel.prototype._sumTree">
            function <span class="apidocSignatureSpan">compressjs.FenwickModel.prototype.</span>_sumTree
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.FenwickModel.prototype.clone">
            function <span class="apidocSignatureSpan">compressjs.FenwickModel.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.FenwickModel.prototype.decode">
            function <span class="apidocSignatureSpan">compressjs.FenwickModel.prototype.</span>decode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.FenwickModel.prototype.encode">
            function <span class="apidocSignatureSpan">compressjs.FenwickModel.prototype.</span>encode
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.Huffman">module compressjs.Huffman</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.Huffman">
            function <span class="apidocSignatureSpan">compressjs.</span>Huffman
            <span class="apidocSignatureSpan">(size, root, bitstream, max_weight)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.compressFile">
            function <span class="apidocSignatureSpan">compressjs.Huffman.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.Huffman.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.factory">
            function <span class="apidocSignatureSpan">compressjs.Huffman.</span>factory
            <span class="apidocSignatureSpan">(bitstream, max_weight)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.Huffman.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.Huffman.prototype">module compressjs.Huffman.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.prototype.decode">
            function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>decode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.prototype.encode">
            function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>encode
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.prototype.increment">
            function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>increment
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.prototype.leader">
            function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>leader
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.prototype.readid">
            function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>readid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.prototype.scale">
            function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>scale
            <span class="apidocSignatureSpan">(bits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.prototype.sendid">
            function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>sendid
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.prototype.slide">
            function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>slide
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Huffman.prototype.split">
            function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>split
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.HuffmanAllocator">module compressjs.HuffmanAllocator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.HuffmanAllocator.allocateHuffmanCodeLengths">
            function <span class="apidocSignatureSpan">compressjs.HuffmanAllocator.</span>allocateHuffmanCodeLengths
            <span class="apidocSignatureSpan">(array, maximumLength)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.LogDistanceModel">module compressjs.LogDistanceModel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.LogDistanceModel.LogDistanceModel">
            function <span class="apidocSignatureSpan">compressjs.</span>LogDistanceModel
            <span class="apidocSignatureSpan">(size, extraStates, lgDistanceModelFactory, lengthBitsModelFactory)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.LogDistanceModel.prototype">module compressjs.LogDistanceModel.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.LogDistanceModel.prototype.decode">
            function <span class="apidocSignatureSpan">compressjs.LogDistanceModel.prototype.</span>decode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.LogDistanceModel.prototype.encode">
            function <span class="apidocSignatureSpan">compressjs.LogDistanceModel.prototype.</span>encode
            <span class="apidocSignatureSpan">(distance)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.Lzjb">module compressjs.Lzjb</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Lzjb.compressFile">
            function <span class="apidocSignatureSpan">compressjs.Lzjb.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Lzjb.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.Lzjb.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.Lzjb.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.LzjbR">module compressjs.LzjbR</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.LzjbR.compressFile">
            function <span class="apidocSignatureSpan">compressjs.LzjbR.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.LzjbR.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.LzjbR.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.LzjbR.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.Lzp3">module compressjs.Lzp3</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Lzp3.compressFile">
            function <span class="apidocSignatureSpan">compressjs.Lzp3.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Lzp3.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.Lzp3.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.Lzp3.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.MTFModel">module compressjs.MTFModel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.MTFModel.MTFModel">
            function <span class="apidocSignatureSpan">compressjs.</span>MTFModel
            <span class="apidocSignatureSpan">(coder, size, max_prob, increment, betterEscape)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.MTFModel.compressFile">
            function <span class="apidocSignatureSpan">compressjs.MTFModel.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.MTFModel.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.MTFModel.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.MTFModel.factory">
            function <span class="apidocSignatureSpan">compressjs.MTFModel.</span>factory
            <span class="apidocSignatureSpan">(coder, max_prob, increment, betterEscape)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.MTFModel.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.MTFModel.prototype">module compressjs.MTFModel.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.MTFModel.prototype._rescale">
            function <span class="apidocSignatureSpan">compressjs.MTFModel.prototype.</span>_rescale
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.MTFModel.prototype._update">
            function <span class="apidocSignatureSpan">compressjs.MTFModel.prototype.</span>_update
            <span class="apidocSignatureSpan">(symbol, index, sy_f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.MTFModel.prototype.clone">
            function <span class="apidocSignatureSpan">compressjs.MTFModel.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.MTFModel.prototype.decode">
            function <span class="apidocSignatureSpan">compressjs.MTFModel.prototype.</span>decode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.MTFModel.prototype.encode">
            function <span class="apidocSignatureSpan">compressjs.MTFModel.prototype.</span>encode
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.NoModel">module compressjs.NoModel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.NoModel.NoModel">
            function <span class="apidocSignatureSpan">compressjs.</span>NoModel
            <span class="apidocSignatureSpan">(bitstream, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.NoModel.compressFile">
            function <span class="apidocSignatureSpan">compressjs.NoModel.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.NoModel.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.NoModel.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.NoModel.factory">
            function <span class="apidocSignatureSpan">compressjs.NoModel.</span>factory
            <span class="apidocSignatureSpan">(bitstream)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.NoModel.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.NoModel.prototype">module compressjs.NoModel.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.NoModel.prototype.decode">
            function <span class="apidocSignatureSpan">compressjs.NoModel.prototype.</span>decode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.NoModel.prototype.encode">
            function <span class="apidocSignatureSpan">compressjs.NoModel.prototype.</span>encode
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.PPM">module compressjs.PPM</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.PPM.PPM">
            function <span class="apidocSignatureSpan">compressjs.</span>PPM
            <span class="apidocSignatureSpan">(coder, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.PPM.compressFile">
            function <span class="apidocSignatureSpan">compressjs.PPM.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.PPM.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.PPM.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.PPM.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.PPM.prototype">module compressjs.PPM.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.PPM.prototype.decode">
            function <span class="apidocSignatureSpan">compressjs.PPM.prototype.</span>decode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.PPM.prototype.encode">
            function <span class="apidocSignatureSpan">compressjs.PPM.prototype.</span>encode
            <span class="apidocSignatureSpan">(symbol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.PPM.prototype.update">
            function <span class="apidocSignatureSpan">compressjs.PPM.prototype.</span>update
            <span class="apidocSignatureSpan">(symbol, contextString, matchLevel)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.RangeCoder">module compressjs.RangeCoder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.RangeCoder">
            function <span class="apidocSignatureSpan">compressjs.</span>RangeCoder
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.RangeCoder.prototype">module compressjs.RangeCoder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.decodeBit">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeBit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.decodeByte">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeByte
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.decodeCulFreq">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeCulFreq
            <span class="apidocSignatureSpan">(tot_f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.decodeCulShift">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeCulShift
            <span class="apidocSignatureSpan">(shift)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.decodeFinish">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeFinish
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.decodeShort">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeShort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.decodeStart">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeStart
            <span class="apidocSignatureSpan">(skipInitialRead)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.decodeUpdate">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeUpdate
            <span class="apidocSignatureSpan">(sy_f, lt_f, tot_f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.encodeBit">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeBit
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.encodeByte">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeByte
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.encodeFinish">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeFinish
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.encodeFreq">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeFreq
            <span class="apidocSignatureSpan">(sy_f, lt_f, tot_f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.encodeShift">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeShift
            <span class="apidocSignatureSpan">(sy_f, lt_f, shift)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.encodeShort">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeShort
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.encodeStart">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeStart
            <span class="apidocSignatureSpan">(c, initlength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.readBit">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>readBit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.readByte">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>readByte
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.writeBit">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>writeBit
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.RangeCoder.prototype.writeByte">
            function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>writeByte
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.Simple">module compressjs.Simple</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Simple.compressFile">
            function <span class="apidocSignatureSpan">compressjs.Simple.</span>compressFile
            <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Simple.decompressFile">
            function <span class="apidocSignatureSpan">compressjs.Simple.</span>decompressFile
            <span class="apidocSignatureSpan">(inStream, outStream)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">compressjs.Simple.</span>MAGIC</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.Stream">module compressjs.Stream</a><ol>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">compressjs.Stream.</span>EOF</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.Stream.prototype">module compressjs.Stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Stream.prototype.eof">
            function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>eof
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Stream.prototype.flush">
            function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Stream.prototype.read">
            function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>read
            <span class="apidocSignatureSpan">(buf, bufOffset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Stream.prototype.readByte">
            function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>readByte
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Stream.prototype.seek">
            function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>seek
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Stream.prototype.tell">
            function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>tell
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Stream.prototype.write">
            function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>write
            <span class="apidocSignatureSpan">(buf, bufOffset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Stream.prototype.writeByte">
            function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>writeByte
            <span class="apidocSignatureSpan">(_byte)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.compressjs.Util">module compressjs.Util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.arraycopy">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>arraycopy
            <span class="apidocSignatureSpan">(dst, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.coerceInputStream">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>coerceInputStream
            <span class="apidocSignatureSpan">(input, forceRead)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.coerceOutputStream">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>coerceOutputStream
            <span class="apidocSignatureSpan">(output, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.compressFileHelper">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>compressFileHelper
            <span class="apidocSignatureSpan">(magic, guts, suppressFinalByte)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.compressWithModel">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>compressWithModel
            <span class="apidocSignatureSpan">(inStream, fileSize, model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.decompressFileHelper">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>decompressFileHelper
            <span class="apidocSignatureSpan">(magic, guts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.decompressWithModel">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>decompressWithModel
            <span class="apidocSignatureSpan">(outStream, fileSize, model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.fls">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>fls
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.log2c">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>log2c
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.makeS32Buffer">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>makeS32Buffer
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.makeU16Buffer">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>makeU16Buffer
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.makeU32Buffer">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>makeU32Buffer
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.makeU8Buffer">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>makeU8Buffer
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.readUnsignedNumber">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>readUnsignedNumber
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.compressjs.Util.writeUnsignedNumber">
            function <span class="apidocSignatureSpan">compressjs.Util.</span>writeUnsignedNumber
            <span class="apidocSignatureSpan">(output, n)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs" id="apidoc.module.compressjs">module compressjs</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.BitStream" id="apidoc.element.compressjs.BitStream">
        function <span class="apidocSignatureSpan">compressjs.</span>BitStream
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BitStream = function (stream) {
    (function() {
        var bufferByte = 0x100; // private var for readers
        this.readBit = function() {
            if ((bufferByte &amp; 0xFF) === 0) {
                var ch = stream.readByte();
                if (ch === Stream.EOF) {
                    this._eof = true;
                    return ch;<span class="apidocCodeCommentSpan"> /* !!! */
</span>                }
                bufferByte = (ch &lt;&lt; 1) | 1;
            }
            var bit = (bufferByte &amp; 0x100) ? 1 : 0;
            bufferByte &lt;&lt;= 1;
            return bit;
        };
        // seekable iff the provided stream is
        this.seekBit = function(pos) {
            var n_byte = pos &gt;&gt;&gt; 3;
            var n_bit = pos - (n_byte*8);
            this.seek(n_byte);
            this._eof = false;
            this.readBits(n_bit);
        };
        this.tellBit = function() {
            var pos = stream.tell() * 8;
            var b = bufferByte;
            while ((b &amp; 0xFF) !== 0) {
                pos--;
                b &lt;&lt;= 1;
            }
            return pos;
        };
        // implement byte stream interface as well.
        this.readByte = function() {
            if ((bufferByte &amp; 0xFF) === 0) {
                return stream.readByte();
            }
            return this.readBits(8);
        };
        this.seek = function(pos) {
            stream.seek(pos);
            bufferByte = 0x100;
        };
    }).call(this);
    (function() {
        var bufferByte = 1; // private var for writers
        this.writeBit = function(b) {
            bufferByte &lt;&lt;= 1;
            if (b) { bufferByte |= 1; }
            if (bufferByte &amp; 0x100) {
                stream.writeByte(bufferByte &amp; 0xFF);
                bufferByte = 1;
            }
        };
        // implement byte stream interface as well
        this.writeByte = function(_byte) {
            if (bufferByte===1) {
                stream.writeByte(_byte);
            } else {
                stream.writeBits(8, _byte);
            }
        };
        this.flush = function() {
            while (bufferByte !== 1) {
                this.writeBit(0);
            }
            if (stream.flush) { stream.flush(); }
        };
    }).call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Context1Model" id="apidoc.element.compressjs.Context1Model">
        function <span class="apidocSignatureSpan">compressjs.</span>Context1Model
        <span class="apidocSignatureSpan">(modelFactory, contextSize, alphabetSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Context1Model = function (modelFactory, contextSize, alphabetSize) {
  var i;
  this.literalModel = [];
  // even if there's an EOF symbol, we don't need a context for it!
  for (i=0; i&lt;contextSize; i++) {
    this.literalModel[i] = modelFactory(alphabetSize);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DefSumModel" id="apidoc.element.compressjs.DefSumModel">
        function <span class="apidocSignatureSpan">compressjs.</span>DefSumModel
        <span class="apidocSignatureSpan">(coder, size, isDecoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefSumModel = function (coder, size, isDecoder) {
  var i;
  console.assert(size &lt; 300); // not meant for sparse
  var ESCAPE = this.numSyms = size;
  this.coder = coder;
  this.prob = Util.makeU16Buffer(size+2);<span class="apidocCodeCommentSpan"> /* size + ESC + 1 */
</span>  this.escape = Util.makeU16Buffer(size+1);  /* size + 1*/
  this.update = Util.makeU16Buffer(size+1); /* size + ESC */
  this.prob[ESCAPE+1] = PROB_TOTAL;
  for (i=0; i&lt;=this.numSyms; i++) {
    this.escape[i] = i;
  }
  this.updateCount = 0;
  this.updateThresh = PROB_TOTAL - Math.floor(PROB_TOTAL / 2);
  if (!isDecoder) { return; }
  // extra tables for fast decoding
  this.probToSym = Util.makeU16Buffer(PROB_TOTAL);
  this.escProbToSym = Util.makeU16Buffer(this.numSyms);
  for (i=0; i&lt;PROB_TOTAL; i++) {
    this.probToSym[i] = ESCAPE;
  }
  for (i=0; i&lt;this.numSyms; i++) {
    this.escProbToSym[i] = i;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DeflateDistanceModel" id="apidoc.element.compressjs.DeflateDistanceModel">
        function <span class="apidocSignatureSpan">compressjs.</span>DeflateDistanceModel
        <span class="apidocSignatureSpan">(size, extraStates, lgDistanceModelFactory, lengthBitsModelFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DeflateDistanceModel = function (size, extraStates, lgDistanceModelFactory, lengthBitsModelFactory) {
    var i;
    var bits = Util.fls(size-1);
    this.extraStates = +extraStates || 0;
    this.lgDistanceModel = lgDistanceModelFactory(2*bits + extraStates);
    // this.distanceModel[n] used for distances which are n-bits long,
    // but only n-2 bits are encoded: the top bit is known to be one,
    // and the next bit is encoded by the lgDistanceModel.
    this.distanceModel = [];
    for (i=3 ; i &lt;= bits; i++) {
        var numBits = i - 2;
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder" id="apidoc.element.compressjs.DummyRangeCoder">
        function <span class="apidocSignatureSpan">compressjs.</span>DummyRangeCoder
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DummyRangeCoder = function (stream) {
    RangeCoder.call(this, stream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.FenwickModel" id="apidoc.element.compressjs.FenwickModel">
        function <span class="apidocSignatureSpan">compressjs.</span>FenwickModel
        <span class="apidocSignatureSpan">(coder, size, max_prob, increment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FenwickModel = function (coder, size, max_prob, increment) {
    this.coder = coder;
    this.numSyms = size + 1; // save space for an escape symbol
    this.tree = Util.makeU32Buffer(this.numSyms*2);
    this.increment = (+increment) || DEFAULT_INCREMENT;
    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;
    // sanity-check to prevent overflow.
    console.assert((this.max_prob + (this.increment-1)) &lt;= 0xFFFF);
    console.assert(size &lt;= 0xFFFF);
    // record escape probability as 1.
    var i;
    for (i=0; i&lt;size; i++) {
        this.tree[this.numSyms + i] = // escape prob=1, sym prob = 0
            (1 &lt;&lt; ESC_SHIFT) | (0 &lt;&lt; SYM_SHIFT);
    }
    this.tree[this.numSyms + i] = // escape prob = 0, sym prob = 1
        (0 &lt;&lt; ESC_SHIFT) | (this.increment &lt;&lt; SYM_SHIFT);
    this._sumTree();
    // probability sums are in this.tree[1].  this.tree[0] is unused.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Huffman" id="apidoc.element.compressjs.Huffman">
        function <span class="apidocSignatureSpan">compressjs.</span>Huffman
        <span class="apidocSignatureSpan">(size, root, bitstream, max_weight)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Huffman = function (size, root, bitstream, max_weight) {
  var i;
  //  default: all alphabet symbols are used

  console.assert(size &amp;&amp; typeof(size)==='number');
  if( !root || root &gt; size )
      root = size;

  //  create the initial escape node
  //  at the tree root

  if ( root &lt;&lt;= 1 ) {
      root--;
  }

  // create root+1 htables (coding table)
  // XXX this could be views on a backing Uint32 array?
  this.table = [];
  for (i=0; i&lt;=root; i++) {
    this.table[i] = new HTable(0,0,0,0);
  }

  // this.map =&gt; mapping for symbols to nodes
  this.map = [];
  // this.size =&gt; the alphabet size
  if( this.size = size ) {
    for (i=0; i&lt;size; i++) {
      this.map[i] = 0;
    }
  }

  // this.esc  =&gt; the current tree height
  // this.root =&gt; the root of the tree
  this.esc = this.root = root;

  if (bitstream) {
    this.readBit = bitstream.readBit.bind(bitstream);
    this.writeBit = bitstream.writeBit.bind(bitstream);
  }
  this.max_weight = max_weight; // may be null or undefined
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.LogDistanceModel" id="apidoc.element.compressjs.LogDistanceModel">
        function <span class="apidocSignatureSpan">compressjs.</span>LogDistanceModel
        <span class="apidocSignatureSpan">(size, extraStates, lgDistanceModelFactory, lengthBitsModelFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LogDistanceModel = function (size, extraStates, lgDistanceModelFactory, lengthBitsModelFactory) {
    var i;
    var bits = Util.fls(size-1);
    this.extraStates = +extraStates || 0;
    this.lgDistanceModel = lgDistanceModelFactory(1 + bits + extraStates);
    // this.distanceModel[n] used for distances which are n-bits long,
    // but only n-1 bits are encoded: the top bit is known to be one.
    this.distanceModel = [];
    for (i=2 ; i &lt;= bits; i++) {
        var numBits = i - 1;
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.MTFModel" id="apidoc.element.compressjs.MTFModel">
        function <span class="apidocSignatureSpan">compressjs.</span>MTFModel
        <span class="apidocSignatureSpan">(coder, size, max_prob, increment, betterEscape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MTFModel = function (coder, size, max_prob, increment, betterEscape) {
    this.coder = coder;
    this.increment = (+increment) || DEFAULT_INCREMENT;
    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;
    console.assert((this.max_prob + (this.increment-1)) &lt;= 0xFFFF);
    this.sym = Util.makeU16Buffer(size+1);
    this.prob= Util.makeU16Buffer(size+2);
    this.sym[0] = size; // escape code
    this.prob[0]= 0;
    this.seenSyms = 1;
    // total probability always found in this.prob[this.seenSyms]
    this.prob[this.seenSyms] = this.increment;
    this.numSyms = size;
    if (betterEscape) {
        this.sortedSeen = [size];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.NoModel" id="apidoc.element.compressjs.NoModel">
        function <span class="apidocSignatureSpan">compressjs.</span>NoModel
        <span class="apidocSignatureSpan">(bitstream, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NoModel = function (bitstream, size) {
  this.bitstream = bitstream;
  this.bits = Util.fls(size-1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.PPM" id="apidoc.element.compressjs.PPM">
        function <span class="apidocSignatureSpan">compressjs.</span>PPM
        <span class="apidocSignatureSpan">(coder, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PPM = function (coder, size) {
  this.window = new Window();
  this.contexts = Object.create(null);
  // brain-dead '-1' context, using full exclusion
  var Cm1Context = function() { };
  Cm1Context.prototype.encode = function(symbol, exclude) {
    var i, lt_f = 0;
    for (i=0; i&lt;symbol; i++) {
      if (!exclude[i]) {
        lt_f++;
      }
    }
    var tot_f = size - exclude.total;
    coder.encodeFreq(1, lt_f, tot_f);
  };
  Cm1Context.prototype.decode = function(exclude) {
    var i, symbol, lt_f;
    var tot_f = size - exclude.total;
    symbol = lt_f = coder.decodeCulFreq(tot_f);
    for (i=0; i&lt;=symbol; i++) {
      if (exclude[i]) {
        symbol++;
      }
    }
    coder.decodeUpdate(1, lt_f, tot_f);
    return symbol;
  };
  this.cm1coder = new Cm1Context();

  var DenseMTFModel = function() {
    this.sym = [size];
    this.prob= [0, DMM_INCREMENT];
    this.refcount = 0;
  };
  DenseMTFModel.prototype._rescale = function() {
    var seenSyms = this.sym.length;
    var i, j, total=0;
    var noEscape = true;
    for(i=0, j=0; i&lt;seenSyms; i++) {
      var sym = this.sym[i];
      var sy_f = this.prob[i+1] - this.prob[i];
      sy_f &gt;&gt;&gt;= 1;
      if (sy_f &gt; 0) {
        if (sym === size) {
          noEscape = false;
        }
        this.sym[j] = sym;
        this.prob[j++] = total;
        total += sy_f;
      }
    }
    this.prob[j] = total;
    seenSyms = this.sym.length = j;
    this.prob.length = seenSyms + 1;
    // don't allow escape to go to zero prob if we still need it
    if (noEscape &amp;&amp; seenSyms &lt; size) {
      total = this._update(size/*escape*/, seenSyms/*at end*/, 0, 1);
    }
    return total;
  };
  DenseMTFModel.prototype.update = function(symbol, incr) {
    // find symbol
    var i=0;
    for (i=0; i&lt;this.sym.length; i++) {
      if (this.sym[i] === symbol) {
        return this._update(symbol, i, this.prob[i+1] - this.prob[i], incr);
      }
    }
    // symbol escaped
    return this._update(symbol, i, 0, incr);
  };
  DenseMTFModel.prototype._update = function(symbol, index, sy_f, incr) {
    var seenSyms = this.sym.length;
    var i, j, tot_f;
    // move this symbol to the end
    for (j=index; j&lt;seenSyms-1; j++) {
      this.sym[j] = this.sym[j+1];
      this.prob[j] = this.prob[j+1] - sy_f;
    }
    // "method D" -- if we add a new escaped symbol, escape &amp; the symbol
    // both increase by 1/2.
    if (index &lt; seenSyms) {
      this.sym[j] = symbol;
      this.prob[j] = this.prob[j+1] - sy_f;
      // increase frequency for this symbol, and total freq at same time
      this.prob[seenSyms] = tot_f =
        this.prob[seenSyms] + incr;
    } else { // add to the end
      tot_f = this.prob[seenSyms];
      this.sym[index] = symbol;
      this.prob[index] = tot_f;
      tot_f += incr;
      this.prob[++seenSyms] = tot_f;
      // remove probability of escape if table just filled up
      if (this.sym.length &gt; size) {
        for (i=0; i&lt;seenSyms; i++) {
          if (size === this.sym[i]) {
            // found it.
            this._update(size, i, this.prob[i+1] - this.prob[i], -1);
            this.sym.length--;
            this.prob.length--;
            tot_f = this.prob[this.prob.length-1];
          }
        }
      }
    }
    if (tot_f &gt;= DMM_MAX_PROB) { tot_f = this._rescale(); }
    return tot_f;
  };
  DenseMTFModel.prototype.encode = function(symbol, exclude) {
    // look for symbol, from most-recent to oldest
    var i, j, sy_f, lt_f, tot_f, seenSyms = this.sym.length;
    var ex_seen = 0, ex_lt_f = 0, ex_tot_f = 0, ex_sy_f;
    for (i=seenSyms-1; i&gt;=0; i--) {
      lt_f = this.prob[i];
      sy_f = this.prob[i + 1] - lt_f;
      if (symbol === this.sym[i]) {
        // ok, found it.
        // count up the rest of the probabilities
        for (j=i-1; j&gt;=0 &amp;&amp; ex_seen &lt; exclude.total; j--) {
          if (exclude[this.sym[j]]) {
            ex_seen += 1;
            ex_sy_f = this.prob[j+1] - this.prob[j];
            ex_lt_f += ex_sy_f;
            ex_tot_f += ex_sy_f;
          }
        }
        tot_f = this.prob[seenSyms];
        // adjust by excluded symbols ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder" id="apidoc.element.compressjs.RangeCoder">
        function <span class="apidocSignatureSpan">compressjs.</span>RangeCoder
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RangeCoder = function (stream) {
    this.low = 0;<span class="apidocCodeCommentSpan"> /* low end of interval */
</span>    this.range = Top_value; /* length of interval */
    this.buffer = 0; /* buffer for input/output */
    this.help = 0; /* bytes_to_follow / intermediate value */
    this.bytecount = 0; /* counter for output bytes */
    this.stream = stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Stream" id="apidoc.element.compressjs.Stream">
        function <span class="apidocSignatureSpan">compressjs.</span>Stream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Stream = function () {
<span class="apidocCodeCommentSpan">    /* ABSTRACT */
</span>}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.BWT" id="apidoc.module.compressjs.BWT">module compressjs.BWT</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.BWT.bwtransform" id="apidoc.element.compressjs.BWT.bwtransform">
        function <span class="apidocSignatureSpan">compressjs.BWT.</span>bwtransform
        <span class="apidocSignatureSpan">(T, U, A, n, alphabetSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bwtransform = function (T, U, A, n, alphabetSize) {
    var i, pidx;
    ASSERT( T &amp;&amp; U &amp;&amp; A );
    ASSERT( T.length &gt;= n &amp;&amp; U.length &gt;= n &amp;&amp; A.length &gt;= n );
    if (n &lt;= 1) {
        if (n === 1) { U[0] = T[0]; }
        return n;
    }
    if (!alphabetSize) {
        if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }
        else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }
        else throw new Error('Need to specify alphabetSize');
    }
    ASSERT( alphabetSize &gt; 0 );
    if (T.BYTES_PER_ELEMENT) {
        ASSERT( alphabetSize &lt;= (1 &lt;&lt; (T.BYTES_PER_ELEMENT*8) ) );
    }
    pidx = SA_IS(T, A, 0, n, alphabetSize, true);
    U[0] = T[n - 1];
    for (i = 0; i &lt; pidx ; i++) { U[i + 1] = A[i]; }
    for (i += 1; i &lt; n; i++) { U[i] = A[i]; }
    return pidx + 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.BWT.bwtransform2" id="apidoc.element.compressjs.BWT.bwtransform2">
        function <span class="apidocSignatureSpan">compressjs.BWT.</span>bwtransform2
        <span class="apidocSignatureSpan">(T, U, n, alphabetSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bwtransform2 = function (T, U, n, alphabetSize) {
    var i, j, pidx = 0;
    ASSERT( T &amp;&amp; U );
    ASSERT( T.length &gt;= n &amp;&amp; U.length &gt;= n );
    if (n &lt;= 1) {
        if (n === 1) { U[0] = T[0]; }
        return 0;
    }
    if (!alphabetSize) {
        if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }
        else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }
        else throw new Error('Need to specify alphabetSize');
    }
    ASSERT( alphabetSize &gt; 0 );
    if (T.BYTES_PER_ELEMENT) {
        ASSERT( alphabetSize &lt;= (1 &lt;&lt; (T.BYTES_PER_ELEMENT*8) ) );
    }
    // double length of T
    var TT;
    if (T.length &gt;= n*2) {
        TT = T; // do it in place if possible
    } else if (alphabetSize &lt;= 256) {
        TT = Util.makeU8Buffer(n*2);
    } else if (alphabetSize &lt;= 65536) {
        TT = Util.makeU16Buffer(n*2);
    } else {
        TT = Util.makeU32Buffer(n*2);
    }
    if (TT!==T) {
        for (i=0; i&lt;n; i++) { TT[i] = T[i]; }
    }
    for (i=0; i&lt;n; i++) { TT[n+i] = TT[i]; }
    // sort doubled string
    var A = Util.makeS32Buffer(n*2);
    SA_IS(TT, A, 0, n*2, alphabetSize, false);
    for (i=0, j=0; i&lt;2*n; i++) {
        var s = A[i];
        if (s &lt; n) {
            if (s === 0) { pidx = j; }
            if (--s &lt; 0) { s = n-1; }
            U[j++] = T[s];
        }
    }
    ASSERT(j===n);
    return pidx;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.BWT.suffixsort" id="apidoc.element.compressjs.BWT.suffixsort">
        function <span class="apidocSignatureSpan">compressjs.BWT.</span>suffixsort
        <span class="apidocSignatureSpan">(T, SA, n, alphabetSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">suffixsort = function (T, SA, n, alphabetSize) {
    ASSERT( T &amp;&amp; SA &amp;&amp; T.length &gt;= n &amp;&amp; SA.length &gt;= n );
    if (n &lt;= 1) {
        if (n === 1) { SA[0] = 0; }
        return 0;
    }
    if (!alphabetSize) {
        if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }
        else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }
        else throw new Error('Need to specify alphabetSize');
    }
    ASSERT( alphabetSize &gt; 0 );
    if (T.BYTES_PER_ELEMENT) {
        ASSERT( alphabetSize &lt;= (1 &lt;&lt; (T.BYTES_PER_ELEMENT*8) ) );
    }
    return SA_IS(T, SA, 0, n, alphabetSize, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.BWT.unbwtransform" id="apidoc.element.compressjs.BWT.unbwtransform">
        function <span class="apidocSignatureSpan">compressjs.BWT.</span>unbwtransform
        <span class="apidocSignatureSpan">(T, U, LF, n, pidx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbwtransform = function (T, U, LF, n, pidx) {
    var C = Util.makeU32Buffer(256);
    var i, t;
    for (i=0; i&lt;256; i++) { C[i] = 0; }
    for (i=0; i&lt;n; i++) { LF[i] = C[T[i]]++; }
    for (i=0, t=0; i&lt;256; i++) { t += C[i]; C[i] = t - C[i]; }
    for (i=n-1, t=0; i&gt;=0; i--) {
        t = LF[t] + C[U[i]=T[t]];
        t += (t&lt;pidx) ? 1 : 0;
    }
    C = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.BWTC" id="apidoc.module.compressjs.BWTC">module compressjs.BWTC</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.BWTC.compressFile" id="apidoc.element.compressjs.BWTC.compressFile">
        function <span class="apidocSignatureSpan">compressjs.BWTC.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.BWTC.decompressFile" id="apidoc.element.compressjs.BWTC.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.BWTC.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.BitStream" id="apidoc.module.compressjs.BitStream">module compressjs.BitStream</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.BitStream.BitStream" id="apidoc.element.compressjs.BitStream.BitStream">
        function <span class="apidocSignatureSpan">compressjs.</span>BitStream
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BitStream = function (stream) {
    (function() {
        var bufferByte = 0x100; // private var for readers
        this.readBit = function() {
            if ((bufferByte &amp; 0xFF) === 0) {
                var ch = stream.readByte();
                if (ch === Stream.EOF) {
                    this._eof = true;
                    return ch;<span class="apidocCodeCommentSpan"> /* !!! */
</span>                }
                bufferByte = (ch &lt;&lt; 1) | 1;
            }
            var bit = (bufferByte &amp; 0x100) ? 1 : 0;
            bufferByte &lt;&lt;= 1;
            return bit;
        };
        // seekable iff the provided stream is
        this.seekBit = function(pos) {
            var n_byte = pos &gt;&gt;&gt; 3;
            var n_bit = pos - (n_byte*8);
            this.seek(n_byte);
            this._eof = false;
            this.readBits(n_bit);
        };
        this.tellBit = function() {
            var pos = stream.tell() * 8;
            var b = bufferByte;
            while ((b &amp; 0xFF) !== 0) {
                pos--;
                b &lt;&lt;= 1;
            }
            return pos;
        };
        // implement byte stream interface as well.
        this.readByte = function() {
            if ((bufferByte &amp; 0xFF) === 0) {
                return stream.readByte();
            }
            return this.readBits(8);
        };
        this.seek = function(pos) {
            stream.seek(pos);
            bufferByte = 0x100;
        };
    }).call(this);
    (function() {
        var bufferByte = 1; // private var for writers
        this.writeBit = function(b) {
            bufferByte &lt;&lt;= 1;
            if (b) { bufferByte |= 1; }
            if (bufferByte &amp; 0x100) {
                stream.writeByte(bufferByte &amp; 0xFF);
                bufferByte = 1;
            }
        };
        // implement byte stream interface as well
        this.writeByte = function(_byte) {
            if (bufferByte===1) {
                stream.writeByte(_byte);
            } else {
                stream.writeBits(8, _byte);
            }
        };
        this.flush = function() {
            while (bufferByte !== 1) {
                this.writeBit(0);
            }
            if (stream.flush) { stream.flush(); }
        };
    }).call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.BitStream.prototype" id="apidoc.module.compressjs.BitStream.prototype">module compressjs.BitStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.BitStream.prototype.readBits" id="apidoc.element.compressjs.BitStream.prototype.readBits">
        function <span class="apidocSignatureSpan">compressjs.BitStream.prototype.</span>readBits
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBits = function (n) {
    var i, r = 0, b;
    if (n &gt; 31) {
        r = this.readBits(n-16)*0x10000; // fp multiply, not shift
        return r + this.readBits(16);
    }
    for (i = 0; i &lt; n; i++) {
        r &lt;&lt;= 1; // this could make a negative value if n&gt;31
        // bits read past EOF are all zeros!
        if (this.readBit() &gt; 0) { r++; }
    }
    return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.BitStream.prototype.writeBits" id="apidoc.element.compressjs.BitStream.prototype.writeBits">
        function <span class="apidocSignatureSpan">compressjs.BitStream.prototype.</span>writeBits
        <span class="apidocSignatureSpan">(n, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBits = function (n, value) {
    if (n &gt; 32) {
        var low = (value &amp; 0xFFFF);
        var high = (value - low) / (0x10000); // fp division, not shift
        this.writeBits(n-16, high);
        this.writeBits(16, low);
        return;
    }
    var i;
    for (i = n-1; i &gt;= 0; i--) {
        this.writeBit( (value &gt;&gt;&gt; i) &amp; 1 );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.Bzip2" id="apidoc.module.compressjs.Bzip2">module compressjs.Bzip2</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.Bzip2.compressFile" id="apidoc.element.compressjs.Bzip2.compressFile">
        function <span class="apidocSignatureSpan">compressjs.Bzip2.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
  inStream = Util.coerceInputStream(inStream);
  var o = Util.coerceOutputStream(outStream, outStream);
  outStream = new BitStream(o.stream);

  var blockSizeMultiplier = 9;
  if (typeof(props)==='number') {
    blockSizeMultiplier = props;
  }
  if (blockSizeMultiplier &lt; 1 || blockSizeMultiplier &gt; 9) {
    throw new Error('Invalid block size multiplier');
  }

  var blockSize = blockSizeMultiplier * 100000;
  // the C implementation always writes at least length-19 characters,
  // but it reads ahead enough that if the last character written was part
  // of a run, it writes out the full run.
  // That's really annoying to implement.
  // So instead just subtract 19 from the blockSize; in most cases (unless
  // there's a run at the end of the block) this will yield block divisions
  // matching the C implementation.
  blockSize -= 19;

  // write file magic
  outStream.writeByte('B'.charCodeAt(0));
  outStream.writeByte('Z'.charCodeAt(0));
  outStream.writeByte('h'.charCodeAt(0)); // Huffman-coded bzip
  outStream.writeByte('0'.charCodeAt(0) + blockSizeMultiplier);

  // allocate a buffer for the block
  var block = Util.makeU8Buffer(blockSize);
  var streamCRC = 0;
  var length;

  do {
    var crc = new CRC32();
    length = readBlock(inStream, block, blockSize, crc);
    if (length &gt; 0) {
      streamCRC = (((streamCRC &lt;&lt; 1) | (streamCRC&gt;&gt;&gt;31)) ^ crc.getCRC()) &gt;&gt;&gt; 0;
      outStream.writeBits(48, WHOLEPI);
      outStream.writeBits(32, crc.getCRC());
      compressBlock(block, length, outStream);
    }
  } while (length === blockSize);

  // finish up
  outStream.writeBits(48, SQRTPI);
  outStream.writeBits(32, streamCRC);
  outStream.flush(); // get the last bits flushed out
  return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Bzip2.decompressBlock" id="apidoc.element.compressjs.Bzip2.decompressBlock">
        function <span class="apidocSignatureSpan">compressjs.Bzip2.</span>decompressBlock
        <span class="apidocSignatureSpan">(input, pos, output)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressBlock = function (input, pos, output) {
  // make a stream from a buffer, if necessary
  var inputStream = Util.coerceInputStream(input);
  var o = Util.coerceOutputStream(output, output);
  var outputStream = o.stream;
  var bz = new Bunzip(inputStream, outputStream);
  bz.reader.seekBit(pos);
<span class="apidocCodeCommentSpan">  /* Fill the decode buffer for the block */
</span>  var moreBlocks = bz._get_next_block();
  if (moreBlocks) {
    /* Init the CRC for writing */
    bz.blockCRC = new CRC32();

    /* Zero this so the current byte from before the seek is not written */
    bz.writeCopies = 0;

    /* Decompress the block and write to stdout */
    bz._read_bunzip();
    // XXX keep writing?
  }
  return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Bzip2.decompressFile" id="apidoc.element.compressjs.Bzip2.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.Bzip2.</span>decompressFile
        <span class="apidocSignatureSpan">(input, output, multistream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (input, output, multistream) {
  // make a stream from a buffer, if necessary
  var inputStream = Util.coerceInputStream(input);
  var o = Util.coerceOutputStream(output, output);
  var outputStream = o.stream;

  var bz = new Bunzip(inputStream, outputStream);
  while (true) {
    if ('eof' in inputStream &amp;&amp; inputStream.eof()) break;
    if (bz._init_block()) {
      bz._read_bunzip();
    } else {
      var targetStreamCRC = bz.reader.readBits(32);
      if (targetStreamCRC !== bz.streamCRC) {
        _throw(Err.DATA_ERROR, "Bad stream CRC "+
               "(got "+bz.streamCRC.toString(16)+
               " expected "+targetStreamCRC.toString(16)+")");
      }
      if (multistream &amp;&amp;
          'eof' in inputStream &amp;&amp;
          !inputStream.eof()) {
        // note that start_bunzip will also resync the bit reader to next byte
        bz._start_bunzip(inputStream, outputStream);
      } else break;
    }
  }
  return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Bzip2.table" id="apidoc.element.compressjs.Bzip2.table">
        function <span class="apidocSignatureSpan">compressjs.Bzip2.</span>table
        <span class="apidocSignatureSpan">(input, callback, multistream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">table = function (input, callback, multistream) {
  // make a stream from a buffer, if necessary
  var inputStream = new Stream();
  inputStream.delegate = Util.coerceInputStream(input);
  inputStream.pos = 0;
  inputStream.readByte = function() {
    this.pos++;
    return this.delegate.readByte();
  };
  inputStream.tell = function() { return this.pos; };
  if (inputStream.delegate.eof) {
    inputStream.eof = inputStream.delegate.eof.bind(inputStream.delegate);
  }
  var outputStream = new Stream();
  outputStream.pos = 0;
  outputStream.writeByte = function() { this.pos++; };

  var bz = new Bunzip(inputStream, outputStream);
  var blockSize = bz.dbufSize;
  while (true) {
    if ('eof' in inputStream &amp;&amp; inputStream.eof()) break;

    var position = bz.reader.tellBit();

    if (bz._init_block()) {
      var start = outputStream.pos;
      bz._read_bunzip();
      callback(position, outputStream.pos - start);
    } else {
      var crc = bz.reader.readBits(32); // (but we ignore the crc)
      if (multistream &amp;&amp;
          'eof' in inputStream &amp;&amp;
          !inputStream.eof()) {
        // note that start_bunzip will also resync the bit reader to next byte
        bz._start_bunzip(inputStream, outputStream);
        console.assert(bz.dbufSize === blockSize,
                       "shouldn't change block size within multistream file");
      } else break;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.Context1Model" id="apidoc.module.compressjs.Context1Model">module compressjs.Context1Model</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.Context1Model.Context1Model" id="apidoc.element.compressjs.Context1Model.Context1Model">
        function <span class="apidocSignatureSpan">compressjs.</span>Context1Model
        <span class="apidocSignatureSpan">(modelFactory, contextSize, alphabetSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Context1Model = function (modelFactory, contextSize, alphabetSize) {
  var i;
  this.literalModel = [];
  // even if there's an EOF symbol, we don't need a context for it!
  for (i=0; i&lt;contextSize; i++) {
    this.literalModel[i] = modelFactory(alphabetSize);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Context1Model.compressFile" id="apidoc.element.compressjs.Context1Model.compressFile">
        function <span class="apidocSignatureSpan">compressjs.Context1Model.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Context1Model.decompressFile" id="apidoc.element.compressjs.Context1Model.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.Context1Model.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.Context1Model.prototype" id="apidoc.module.compressjs.Context1Model.prototype">module compressjs.Context1Model.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.Context1Model.prototype.decode" id="apidoc.element.compressjs.Context1Model.prototype.decode">
        function <span class="apidocSignatureSpan">compressjs.Context1Model.prototype.</span>decode
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (context) {
  return this.literalModel[context].decode();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var l = 4 + ((lgDistance-3)*2) + nextBit;
    this.lgDistanceModel.encode(l + this.extraStates);
    // now encode the rest of the bits.
    var rest = distance &amp; ((1 &lt;&lt; (lgDistance-2)) - 1);
    this.distanceModel[lgDistance].encode(rest);
};
DeflateDistanceModel.prototype.decode = function() {
    var l = this.lgDistanceModel.<span class="apidocCodeKeywordSpan">decode</span>() - this.extraStates;
    if (l &lt; 4) {
        return l; // this is a small distance or an 'extra state'
    }
    var nextBit = (l&amp;1);
    var lgDistance = ((l-4) &gt;&gt;&gt; 1) + 3;
    var rest = this.distanceModel[lgDistance].decode();
    return ((2+nextBit) &lt;&lt; (lgDistance-2)) + rest;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Context1Model.prototype.encode" id="apidoc.element.compressjs.Context1Model.prototype.encode">
        function <span class="apidocSignatureSpan">compressjs.Context1Model.prototype.</span>encode
        <span class="apidocSignatureSpan">(ch, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (ch, context) {
  this.literalModel[context].encode(ch);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
};
/* you can give this model arguments between 0 and (size-1), or else
   a negative argument which is one of the 'extra states'. */
DeflateDistanceModel.prototype.encode = function(distance) {
    if (distance &lt; 4) { // small distance or an 'extra state'
        this.lgDistanceModel.<span class="apidocCodeKeywordSpan">encode</span>(distance + this.extraStates);
        return;
    }
    var lgDistance = Util.fls(distance);
    console.assert(distance &amp; (1&lt;&lt;(lgDistance-1))); // top bit is set
    console.assert(lgDistance &gt;= 3);
    var nextBit = (distance &amp; (1 &lt;&lt; (lgDistance-2))) ? 1 : 0;
    var l = 4 + ((lgDistance-3)*2) + nextBit;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.DefSumModel" id="apidoc.module.compressjs.DefSumModel">module compressjs.DefSumModel</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.DefSumModel.DefSumModel" id="apidoc.element.compressjs.DefSumModel.DefSumModel">
        function <span class="apidocSignatureSpan">compressjs.</span>DefSumModel
        <span class="apidocSignatureSpan">(coder, size, isDecoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefSumModel = function (coder, size, isDecoder) {
  var i;
  console.assert(size &lt; 300); // not meant for sparse
  var ESCAPE = this.numSyms = size;
  this.coder = coder;
  this.prob = Util.makeU16Buffer(size+2);<span class="apidocCodeCommentSpan"> /* size + ESC + 1 */
</span>  this.escape = Util.makeU16Buffer(size+1);  /* size + 1*/
  this.update = Util.makeU16Buffer(size+1); /* size + ESC */
  this.prob[ESCAPE+1] = PROB_TOTAL;
  for (i=0; i&lt;=this.numSyms; i++) {
    this.escape[i] = i;
  }
  this.updateCount = 0;
  this.updateThresh = PROB_TOTAL - Math.floor(PROB_TOTAL / 2);
  if (!isDecoder) { return; }
  // extra tables for fast decoding
  this.probToSym = Util.makeU16Buffer(PROB_TOTAL);
  this.escProbToSym = Util.makeU16Buffer(this.numSyms);
  for (i=0; i&lt;PROB_TOTAL; i++) {
    this.probToSym[i] = ESCAPE;
  }
  for (i=0; i&lt;this.numSyms; i++) {
    this.escProbToSym[i] = i;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DefSumModel.compressFile" id="apidoc.element.compressjs.DefSumModel.compressFile">
        function <span class="apidocSignatureSpan">compressjs.DefSumModel.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DefSumModel.decompressFile" id="apidoc.element.compressjs.DefSumModel.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.DefSumModel.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DefSumModel.factory" id="apidoc.element.compressjs.DefSumModel.factory">
        function <span class="apidocSignatureSpan">compressjs.DefSumModel.</span>factory
        <span class="apidocSignatureSpan">(coder, isDecoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (coder, isDecoder) {
  return function(size) { return new DefSumModel(coder, size, isDecoder); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.DefSumModel.prototype" id="apidoc.module.compressjs.DefSumModel.prototype">module compressjs.DefSumModel.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.DefSumModel.prototype._update" id="apidoc.element.compressjs.DefSumModel.prototype._update">
        function <span class="apidocSignatureSpan">compressjs.DefSumModel.prototype.</span>_update
        <span class="apidocSignatureSpan">(symbol, isDecoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_update = function (symbol, isDecoder) {
  if (symbol === this.numSyms) {
    // some special cases for the escape character
    if (this.update[symbol] &gt;= MAX_ESCAPE_COUNT) { return; } // hard limit
    // don't let an escape character trigger an update, because then the
    // escaped character might find itself unescaped after the tables have
    // been updated!
    if (this.updateCount &gt;= (this.updateThresh - 1)) { return; }
  }
  this.update[symbol]++;
  this.updateCount++;
  // is it time to transfer the updated probabilities?
  if (this.updateCount &lt; this.updateThresh) {
    return; //defer update
  }
  var cumProb, cumEscProb, odd, i, j, k;
  this.escape[0] = this.prob[0] = cumProb = cumEscProb = odd = 0;
  for (i=0; i &lt; this.numSyms+1; i++) {
    var newProb = ((this.prob[i+1]-this.prob[i]) &gt;&gt;&gt; 1) + this.update[i];
    if (newProb) {
      // live 'un
      this.prob[i] = cumProb;
      cumProb += newProb;
      if (newProb &amp; 1) { odd++; }
      this.escape[i] = cumEscProb;
    } else {
      // this symbol will escape
      this.prob[i] = cumProb;
      this.escape[i] = cumEscProb;
      cumEscProb++;
    }
  }
  this.prob[i] = cumProb;
  console.assert(cumProb === PROB_TOTAL);
<span class="apidocCodeCommentSpan">  /* how many updates will be required after current probs are halved? */
</span>  this.updateThresh = PROB_TOTAL - Math.floor((cumProb-odd) / 2);
  /* reset the update table */
  for (i=0; i &lt; (this.numSyms + 1); i++) {
    this.update[i] = 0;
  }
  this.update[this.numSyms] = 1; // ensure that escape never goes away
  this.updateCount = 1;
  /* compute decode table, if this is a decoder */
  if (!isDecoder) { return; }
  for (i=0, j=0, k=0; i&lt;(this.numSyms+1); i++) {
    var probLimit = this.prob[i+1];
    for (; j&lt;probLimit; j++) {
      this.probToSym[j] = i;
    }
    var escProbLimit = this.escape[i+1];
    for (; k&lt;escProbLimit; k++) {
      this.escProbToSym[k] = i;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DefSumModel.prototype.decode" id="apidoc.element.compressjs.DefSumModel.prototype.decode">
        function <span class="apidocSignatureSpan">compressjs.DefSumModel.prototype.</span>decode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function () {
  var prob = this.coder.decodeCulShift(LOG_PROB_TOTAL);
  var symbol = this.probToSym[prob];
  var lt_f = this.prob[symbol];
  var sy_f = this.prob[symbol+1] - lt_f;
  this.coder.decodeUpdate(sy_f, lt_f, PROB_TOTAL);
  this._update(symbol, true);
  if (symbol !== this.numSyms) {
    return symbol;
  }
  // escape!
  var tot_f = this.escape[this.numSyms];
  prob = this.coder.decodeCulFreq(tot_f);
  symbol = this.escProbToSym[prob];
  lt_f = this.escape[symbol];
  sy_f = this.escape[symbol+1] - lt_f;
  this.coder.decodeUpdate(sy_f, lt_f, tot_f);
  this._update(symbol, true);
  return symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var l = 4 + ((lgDistance-3)*2) + nextBit;
    this.lgDistanceModel.encode(l + this.extraStates);
    // now encode the rest of the bits.
    var rest = distance &amp; ((1 &lt;&lt; (lgDistance-2)) - 1);
    this.distanceModel[lgDistance].encode(rest);
};
DeflateDistanceModel.prototype.decode = function() {
    var l = this.lgDistanceModel.<span class="apidocCodeKeywordSpan">decode</span>() - this.extraStates;
    if (l &lt; 4) {
        return l; // this is a small distance or an 'extra state'
    }
    var nextBit = (l&amp;1);
    var lgDistance = ((l-4) &gt;&gt;&gt; 1) + 3;
    var rest = this.distanceModel[lgDistance].decode();
    return ((2+nextBit) &lt;&lt; (lgDistance-2)) + rest;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DefSumModel.prototype.encode" id="apidoc.element.compressjs.DefSumModel.prototype.encode">
        function <span class="apidocSignatureSpan">compressjs.DefSumModel.prototype.</span>encode
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (symbol) {
  var lt_f = this.prob[symbol];
  var sy_f = this.prob[symbol+1] - lt_f;
  console.assert(this.prob[this.numSyms+1] === PROB_TOTAL);
  if (sy_f) {
    this.coder.encodeShift(sy_f, lt_f, LOG_PROB_TOTAL);
    return this._update(symbol);
  }
  // escape!
  console.assert(symbol !== this.numSyms); // catch infinite recursion
  this.encode(this.numSyms); // guaranteed non-zero probability
  // code symbol as literal, taking advantage of reduced escape range.
  lt_f = this.escape[symbol];
  sy_f = this.escape[symbol+1] - lt_f;
  var tot_f = this.escape[this.numSyms];
  this.coder.encodeFreq(sy_f, lt_f, tot_f);
  return this._update(symbol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
};
/* you can give this model arguments between 0 and (size-1), or else
   a negative argument which is one of the 'extra states'. */
DeflateDistanceModel.prototype.encode = function(distance) {
    if (distance &lt; 4) { // small distance or an 'extra state'
        this.lgDistanceModel.<span class="apidocCodeKeywordSpan">encode</span>(distance + this.extraStates);
        return;
    }
    var lgDistance = Util.fls(distance);
    console.assert(distance &amp; (1&lt;&lt;(lgDistance-1))); // top bit is set
    console.assert(lgDistance &gt;= 3);
    var nextBit = (distance &amp; (1 &lt;&lt; (lgDistance-2))) ? 1 : 0;
    var l = 4 + ((lgDistance-3)*2) + nextBit;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.DeflateDistanceModel" id="apidoc.module.compressjs.DeflateDistanceModel">module compressjs.DeflateDistanceModel</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.DeflateDistanceModel.DeflateDistanceModel" id="apidoc.element.compressjs.DeflateDistanceModel.DeflateDistanceModel">
        function <span class="apidocSignatureSpan">compressjs.</span>DeflateDistanceModel
        <span class="apidocSignatureSpan">(size, extraStates, lgDistanceModelFactory, lengthBitsModelFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DeflateDistanceModel = function (size, extraStates, lgDistanceModelFactory, lengthBitsModelFactory) {
    var i;
    var bits = Util.fls(size-1);
    this.extraStates = +extraStates || 0;
    this.lgDistanceModel = lgDistanceModelFactory(2*bits + extraStates);
    // this.distanceModel[n] used for distances which are n-bits long,
    // but only n-2 bits are encoded: the top bit is known to be one,
    // and the next bit is encoded by the lgDistanceModel.
    this.distanceModel = [];
    for (i=3 ; i &lt;= bits; i++) {
        var numBits = i - 2;
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.DeflateDistanceModel.prototype" id="apidoc.module.compressjs.DeflateDistanceModel.prototype">module compressjs.DeflateDistanceModel.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.DeflateDistanceModel.prototype.decode" id="apidoc.element.compressjs.DeflateDistanceModel.prototype.decode">
        function <span class="apidocSignatureSpan">compressjs.DeflateDistanceModel.prototype.</span>decode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function () {
    var l = this.lgDistanceModel.decode() - this.extraStates;
    if (l &lt; 4) {
        return l; // this is a small distance or an 'extra state'
    }
    var nextBit = (l&amp;1);
    var lgDistance = ((l-4) &gt;&gt;&gt; 1) + 3;
    var rest = this.distanceModel[lgDistance].decode();
    return ((2+nextBit) &lt;&lt; (lgDistance-2)) + rest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var l = 4 + ((lgDistance-3)*2) + nextBit;
    this.lgDistanceModel.encode(l + this.extraStates);
    // now encode the rest of the bits.
    var rest = distance &amp; ((1 &lt;&lt; (lgDistance-2)) - 1);
    this.distanceModel[lgDistance].encode(rest);
};
DeflateDistanceModel.prototype.decode = function() {
    var l = this.lgDistanceModel.<span class="apidocCodeKeywordSpan">decode</span>() - this.extraStates;
    if (l &lt; 4) {
        return l; // this is a small distance or an 'extra state'
    }
    var nextBit = (l&amp;1);
    var lgDistance = ((l-4) &gt;&gt;&gt; 1) + 3;
    var rest = this.distanceModel[lgDistance].decode();
    return ((2+nextBit) &lt;&lt; (lgDistance-2)) + rest;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DeflateDistanceModel.prototype.encode" id="apidoc.element.compressjs.DeflateDistanceModel.prototype.encode">
        function <span class="apidocSignatureSpan">compressjs.DeflateDistanceModel.prototype.</span>encode
        <span class="apidocSignatureSpan">(distance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (distance) {
    if (distance &lt; 4) { // small distance or an 'extra state'
        this.lgDistanceModel.encode(distance + this.extraStates);
        return;
    }
    var lgDistance = Util.fls(distance);
    console.assert(distance &amp; (1&lt;&lt;(lgDistance-1))); // top bit is set
    console.assert(lgDistance &gt;= 3);
    var nextBit = (distance &amp; (1 &lt;&lt; (lgDistance-2))) ? 1 : 0;
    var l = 4 + ((lgDistance-3)*2) + nextBit;
    this.lgDistanceModel.encode(l + this.extraStates);
    // now encode the rest of the bits.
    var rest = distance &amp; ((1 &lt;&lt; (lgDistance-2)) - 1);
    this.distanceModel[lgDistance].encode(rest);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
};
/* you can give this model arguments between 0 and (size-1), or else
   a negative argument which is one of the 'extra states'. */
DeflateDistanceModel.prototype.encode = function(distance) {
    if (distance &lt; 4) { // small distance or an 'extra state'
        this.lgDistanceModel.<span class="apidocCodeKeywordSpan">encode</span>(distance + this.extraStates);
        return;
    }
    var lgDistance = Util.fls(distance);
    console.assert(distance &amp; (1&lt;&lt;(lgDistance-1))); // top bit is set
    console.assert(lgDistance &gt;= 3);
    var nextBit = (distance &amp; (1 &lt;&lt; (lgDistance-2))) ? 1 : 0;
    var l = 4 + ((lgDistance-3)*2) + nextBit;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.Dmc" id="apidoc.module.compressjs.Dmc">module compressjs.Dmc</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.Dmc.compressFile" id="apidoc.element.compressjs.Dmc.compressFile">
        function <span class="apidocSignatureSpan">compressjs.Dmc.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Dmc.decompressFile" id="apidoc.element.compressjs.Dmc.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.Dmc.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.DummyRangeCoder" id="apidoc.module.compressjs.DummyRangeCoder">module compressjs.DummyRangeCoder</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.DummyRangeCoder" id="apidoc.element.compressjs.DummyRangeCoder.DummyRangeCoder">
        function <span class="apidocSignatureSpan">compressjs.</span>DummyRangeCoder
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DummyRangeCoder = function (stream) {
    RangeCoder.call(this, stream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.DummyRangeCoder.prototype" id="apidoc.module.compressjs.DummyRangeCoder.prototype">module compressjs.DummyRangeCoder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype._read16" id="apidoc.element.compressjs.DummyRangeCoder.prototype._read16">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>_read16
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read16 = function () {
    var hi = this.stream.readByte();
    var lo = this.stream.readByte();
    return (hi&lt;&lt;8) | lo;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype._read8" id="apidoc.element.compressjs.DummyRangeCoder.prototype._read8">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>_read8
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read8 = function () {
    return this.stream.readByte();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype._write16" id="apidoc.element.compressjs.DummyRangeCoder.prototype._write16">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>_write16
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write16 = function (s) {
    this.stream.writeByte((s &gt;&gt;&gt; 8) &amp; 0xFF);
    this.stream.writeByte(s &amp; 0xFF);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype._write8" id="apidoc.element.compressjs.DummyRangeCoder.prototype._write8">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>_write8
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write8 = function (b) {
    Util.writeUnsignedNumber(this.stream, b);
    this.stream.writeByte(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype.decodeCulFreq" id="apidoc.element.compressjs.DummyRangeCoder.prototype.decodeCulFreq">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>decodeCulFreq
        <span class="apidocSignatureSpan">(tot_f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeCulFreq = function (tot_f) {
    console.assert(tot_f &gt; 0);
    this.sy_f = Util.readUnsignedNumber(this.stream);
    this.lt_f = Util.readUnsignedNumber(this.stream);
    this.tot_f= Util.readUnsignedNumber(this.stream);
    if (tot_f !== this.tot_f) {
        console.error('decodeCul* wrong total: got', tot_f,
                      'expected', this.tot_f);
    }
    return (this.sy_f&gt;&gt;&gt;1) + this.lt_f;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (tot_f !== this.tot_f) {
        console.error('decodeCul* wrong total: got', tot_f,
                      'expected', this.tot_f);
    }
    return (this.sy_f&gt;&gt;&gt;1) + this.lt_f;
};
Dummy.prototype.decodeCulShift = function(shift) {
    return this.<span class="apidocCodeKeywordSpan">decodeCulFreq</span>(1&lt;&lt;shift);
};
Dummy.prototype.decodeUpdate = function(sy_f, lt_f, tot_f) {
    console.assert(sy_f &gt; 0);
    console.assert(tot_f &gt; 0);
    if (sy_f !== this.sy_f ||
        lt_f !== this.lt_f ||
        tot_f!== this.tot_f) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype.decodeCulShift" id="apidoc.element.compressjs.DummyRangeCoder.prototype.decodeCulShift">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>decodeCulShift
        <span class="apidocSignatureSpan">(shift)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeCulShift = function (shift) {
    return this.decodeCulFreq(1&lt;&lt;shift);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype.decodeFinish" id="apidoc.element.compressjs.DummyRangeCoder.prototype.decodeFinish">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>decodeFinish
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeFinish = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype.decodeStart" id="apidoc.element.compressjs.DummyRangeCoder.prototype.decodeStart">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>decodeStart
        <span class="apidocSignatureSpan">(skipInitialRead)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeStart = function (skipInitialRead) {
    return skipInitialRead ? 0 : this.stream.readByte();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype.decodeUpdate" id="apidoc.element.compressjs.DummyRangeCoder.prototype.decodeUpdate">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>decodeUpdate
        <span class="apidocSignatureSpan">(sy_f, lt_f, tot_f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeUpdate = function (sy_f, lt_f, tot_f) {
    console.assert(sy_f &gt; 0);
    console.assert(tot_f &gt; 0);
    if (sy_f !== this.sy_f ||
        lt_f !== this.lt_f ||
        tot_f!== this.tot_f) {
        console.error('decodeUpdate wrong parameters; got',
                      sy_f, lt_f, tot_f, 'expected',
                      this.sy_f, this.lt_f, this.tot_f);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype.encodeFinish" id="apidoc.element.compressjs.DummyRangeCoder.prototype.encodeFinish">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>encodeFinish
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeFinish = function () {
    return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype.encodeFreq" id="apidoc.element.compressjs.DummyRangeCoder.prototype.encodeFreq">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>encodeFreq
        <span class="apidocSignatureSpan">(sy_f, lt_f, tot_f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeFreq = function (sy_f, lt_f, tot_f) {
    console.assert(sy_f &gt; 0);
    console.assert(tot_f &gt; 0);
    console.assert(tot_f &lt;= (1&lt;&lt;23));
    if ((sy_f + lt_f) &gt; tot_f) {
        console.error('dummy coder: lt_f + sy_f &gt; tot_f',
                      sy_f, lt_f, tot_f);
    }
    Util.writeUnsignedNumber(this.stream, sy_f);
    Util.writeUnsignedNumber(this.stream, lt_f);
    Util.writeUnsignedNumber(this.stream, tot_f);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                      sy_f, lt_f, tot_f);
    }
    Util.writeUnsignedNumber(this.stream, sy_f);
    Util.writeUnsignedNumber(this.stream, lt_f);
    Util.writeUnsignedNumber(this.stream, tot_f);
};
Dummy.prototype.encodeShift = function(sy_f, lt_f, shift) {
    this.<span class="apidocCodeKeywordSpan">encodeFreq</span>(sy_f, lt_f, 1 &lt;&lt; shift);
};
Dummy.prototype.encodeFinish = function() {
    return 0;
};
Dummy.prototype.decodeStart = function(skipInitialRead) {
    return skipInitialRead ? 0 : this.stream.readByte();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype.encodeShift" id="apidoc.element.compressjs.DummyRangeCoder.prototype.encodeShift">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>encodeShift
        <span class="apidocSignatureSpan">(sy_f, lt_f, shift)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeShift = function (sy_f, lt_f, shift) {
    this.encodeFreq(sy_f, lt_f, 1 &lt;&lt; shift);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.DummyRangeCoder.prototype.encodeStart" id="apidoc.element.compressjs.DummyRangeCoder.prototype.encodeStart">
        function <span class="apidocSignatureSpan">compressjs.DummyRangeCoder.prototype.</span>encodeStart
        <span class="apidocSignatureSpan">(c, initlength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeStart = function (c, initlength) {
    this.stream.writeByte(c);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.FenwickModel" id="apidoc.module.compressjs.FenwickModel">module compressjs.FenwickModel</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.FenwickModel.FenwickModel" id="apidoc.element.compressjs.FenwickModel.FenwickModel">
        function <span class="apidocSignatureSpan">compressjs.</span>FenwickModel
        <span class="apidocSignatureSpan">(coder, size, max_prob, increment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FenwickModel = function (coder, size, max_prob, increment) {
    this.coder = coder;
    this.numSyms = size + 1; // save space for an escape symbol
    this.tree = Util.makeU32Buffer(this.numSyms*2);
    this.increment = (+increment) || DEFAULT_INCREMENT;
    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;
    // sanity-check to prevent overflow.
    console.assert((this.max_prob + (this.increment-1)) &lt;= 0xFFFF);
    console.assert(size &lt;= 0xFFFF);
    // record escape probability as 1.
    var i;
    for (i=0; i&lt;size; i++) {
        this.tree[this.numSyms + i] = // escape prob=1, sym prob = 0
            (1 &lt;&lt; ESC_SHIFT) | (0 &lt;&lt; SYM_SHIFT);
    }
    this.tree[this.numSyms + i] = // escape prob = 0, sym prob = 1
        (0 &lt;&lt; ESC_SHIFT) | (this.increment &lt;&lt; SYM_SHIFT);
    this._sumTree();
    // probability sums are in this.tree[1].  this.tree[0] is unused.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.FenwickModel.compressFile" id="apidoc.element.compressjs.FenwickModel.compressFile">
        function <span class="apidocSignatureSpan">compressjs.FenwickModel.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.FenwickModel.decompressFile" id="apidoc.element.compressjs.FenwickModel.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.FenwickModel.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.FenwickModel.factory" id="apidoc.element.compressjs.FenwickModel.factory">
        function <span class="apidocSignatureSpan">compressjs.FenwickModel.</span>factory
        <span class="apidocSignatureSpan">(coder, max_prob, increment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (coder, max_prob, increment) {
    return function(size) {
        return new FenwickModel(coder, size, max_prob, increment);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.FenwickModel.prototype" id="apidoc.module.compressjs.FenwickModel.prototype">module compressjs.FenwickModel.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.FenwickModel.prototype._decode" id="apidoc.element.compressjs.FenwickModel.prototype._decode">
        function <span class="apidocSignatureSpan">compressjs.FenwickModel.prototype.</span>_decode
        <span class="apidocSignatureSpan">(isEscape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_decode = function (isEscape) {
    var mask = SYM_MASK, shift = SYM_SHIFT;
    var update = (this.increment &lt;&lt; SYM_SHIFT);
    if (isEscape) {
        mask = ESC_MASK;
        update -= (1 &lt;&lt; ESC_SHIFT);
        shift = ESC_SHIFT;
    }
    var tot_f = (this.tree[1] &amp; mask) &gt;&gt;&gt; shift;
    var prob = this.coder.decodeCulFreq(tot_f);
    // travel down the tree looking for this
    var i = 1, lt_f = 0;
    while (i &lt; this.numSyms) {
        this.tree[i] += update;
        // look at probability in left child.
        var leftProb = (this.tree[2*i] &amp; mask) &gt;&gt;&gt; shift;
        i *= 2;
        if ((prob-lt_f) &gt;= leftProb) {
            lt_f += leftProb;
            i++; // take the right child.
        }
    }
    var symbol = i - this.numSyms;
    var sy_f = (this.tree[i] &amp; mask) &gt;&gt;&gt; shift;
    this.tree[i] += update;
    this.coder.decodeUpdate(sy_f, lt_f, tot_f);
    // was this the last escape?
    if (symbol === (this.numSyms-1) &amp;&amp;
        ((this.tree[1] &amp; ESC_MASK) &gt;&gt;&gt; ESC_SHIFT) === 1) {
        update = -this.tree[i]; // zero it out
        while (i &gt;= 1) {
            this.tree[i] += update;
            i = (i &gt;&gt;&gt; 1); // parent
        }
    }
    // rescale?
    if ((( this.tree[1] &amp; SYM_MASK ) &gt;&gt;&gt; SYM_SHIFT) &gt;= this.max_prob) {
        this._rescale();
    }
    return symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.FenwickModel.prototype._rescale" id="apidoc.element.compressjs.FenwickModel.prototype._rescale">
        function <span class="apidocSignatureSpan">compressjs.FenwickModel.prototype.</span>_rescale
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_rescale = function () {
    var i, prob, noEscape = true;
    // scale symbols (possible causing them to escape)
    for (i=0; i &lt; this.numSyms-1; i++) {
        prob = this.tree[this.numSyms + i];
        if ((prob &amp; ESC_MASK) !== 0) {
            // this symbol escapes
            noEscape = false;
            continue;
        }
        prob = (prob &amp; SCALE_MASK) &gt;&gt;&gt; 1;
        if (prob === 0) {
            // this symbol newly escapes
            prob = (1 &lt;&lt; ESC_SHIFT);
            noEscape = false;
        }
        this.tree[this.numSyms + i] = prob;
    }
    // scale the escape symbol
    prob = this.tree[this.numSyms + i];
    prob = (prob &amp; SCALE_MASK) &gt;&gt;&gt; 1;
    // prob should be zero if there are no escaping symbols, otherwise
    // it must be at least 1.
    if (noEscape) { prob = 0; }
    else if (prob === 0) { prob = (1 &lt;&lt; SYM_SHIFT); }
    this.tree[this.numSyms + i] = prob;
    // sum it all up afresh
    this._sumTree();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.FenwickModel.prototype._sumTree" id="apidoc.element.compressjs.FenwickModel.prototype._sumTree">
        function <span class="apidocSignatureSpan">compressjs.FenwickModel.prototype.</span>_sumTree
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sumTree = function () {
    var i;
    // sum it all. (we know we won't overflow)
    for (i=this.numSyms - 1; i &gt; 0; i--) {
        this.tree[i] = this.tree[2*i] + this.tree[2*i + 1];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.FenwickModel.prototype.clone" id="apidoc.element.compressjs.FenwickModel.prototype.clone">
        function <span class="apidocSignatureSpan">compressjs.FenwickModel.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
    var newModel = new FenwickModel(this.coder, this.size,
                                    this.max_prob, this.increment);
    var i;
    for (i=1; i&lt;this.tree.length; i++) {
        newModel.tree[i] = this.tree[i];
    }
    return newModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.FenwickModel.prototype.decode" id="apidoc.element.compressjs.FenwickModel.prototype.decode">
        function <span class="apidocSignatureSpan">compressjs.FenwickModel.prototype.</span>decode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function () {
    var symbol = this._decode(false); // not escape
    if (symbol === (this.numSyms-1)) {
        // this was an escape!
        symbol = this._decode(true); // an escape!
    }
    return symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var l = 4 + ((lgDistance-3)*2) + nextBit;
    this.lgDistanceModel.encode(l + this.extraStates);
    // now encode the rest of the bits.
    var rest = distance &amp; ((1 &lt;&lt; (lgDistance-2)) - 1);
    this.distanceModel[lgDistance].encode(rest);
};
DeflateDistanceModel.prototype.decode = function() {
    var l = this.lgDistanceModel.<span class="apidocCodeKeywordSpan">decode</span>() - this.extraStates;
    if (l &lt; 4) {
        return l; // this is a small distance or an 'extra state'
    }
    var nextBit = (l&amp;1);
    var lgDistance = ((l-4) &gt;&gt;&gt; 1) + 3;
    var rest = this.distanceModel[lgDistance].decode();
    return ((2+nextBit) &lt;&lt; (lgDistance-2)) + rest;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.FenwickModel.prototype.encode" id="apidoc.element.compressjs.FenwickModel.prototype.encode">
        function <span class="apidocSignatureSpan">compressjs.FenwickModel.prototype.</span>encode
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (symbol) {
    var i = this.numSyms + symbol;
    var sy_f = this.tree[i];
    var mask = SYM_MASK, shift = SYM_SHIFT;
    var update = (this.increment &lt;&lt; SYM_SHIFT);

    if ((sy_f &amp; SYM_MASK) === 0) { // escape!
        this.encode(this.numSyms-1);
        mask = ESC_MASK;
        update -= (1&lt;&lt;ESC_SHIFT); // not going to escape no mo'
        shift = ESC_SHIFT;
    } else if (symbol === (this.numSyms-1) &amp;&amp;
               ((this.tree[1] &amp; ESC_MASK) &gt;&gt;&gt; ESC_SHIFT) === 1) {
        // this is the last escape, zero it out
        update = -this.tree[i];
    }
    // sum up the proper lt_f
    var lt_f = 0;
    while (i &gt; 1) {
        var isRight = (i &amp; 1);
        var parent = (i &gt;&gt;&gt; 1);
        // if we're the right child, we need to
        // add the prob from the left child
        if (isRight) {
            lt_f += this.tree[2*parent];
        }
        // update sums
        this.tree[i] += update; // increase sym / decrease esc
        i = parent;
    }
    var tot_f = this.tree[1];
    this.tree[1] += update; // update prob in root
    sy_f = (sy_f &amp; mask) &gt;&gt;&gt; shift;
    lt_f = (lt_f &amp; mask) &gt;&gt;&gt; shift;
    tot_f =(tot_f&amp; mask) &gt;&gt;&gt; shift;
    this.coder.encodeFreq(sy_f, lt_f, tot_f);
    // rescale?
    if ((( this.tree[1] &amp; SYM_MASK ) &gt;&gt;&gt; SYM_SHIFT) &gt;= this.max_prob) {
        this._rescale();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
};
/* you can give this model arguments between 0 and (size-1), or else
   a negative argument which is one of the 'extra states'. */
DeflateDistanceModel.prototype.encode = function(distance) {
    if (distance &lt; 4) { // small distance or an 'extra state'
        this.lgDistanceModel.<span class="apidocCodeKeywordSpan">encode</span>(distance + this.extraStates);
        return;
    }
    var lgDistance = Util.fls(distance);
    console.assert(distance &amp; (1&lt;&lt;(lgDistance-1))); // top bit is set
    console.assert(lgDistance &gt;= 3);
    var nextBit = (distance &amp; (1 &lt;&lt; (lgDistance-2))) ? 1 : 0;
    var l = 4 + ((lgDistance-3)*2) + nextBit;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.Huffman" id="apidoc.module.compressjs.Huffman">module compressjs.Huffman</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.Huffman.Huffman" id="apidoc.element.compressjs.Huffman.Huffman">
        function <span class="apidocSignatureSpan">compressjs.</span>Huffman
        <span class="apidocSignatureSpan">(size, root, bitstream, max_weight)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Huffman = function (size, root, bitstream, max_weight) {
  var i;
  //  default: all alphabet symbols are used

  console.assert(size &amp;&amp; typeof(size)==='number');
  if( !root || root &gt; size )
      root = size;

  //  create the initial escape node
  //  at the tree root

  if ( root &lt;&lt;= 1 ) {
      root--;
  }

  // create root+1 htables (coding table)
  // XXX this could be views on a backing Uint32 array?
  this.table = [];
  for (i=0; i&lt;=root; i++) {
    this.table[i] = new HTable(0,0,0,0);
  }

  // this.map =&gt; mapping for symbols to nodes
  this.map = [];
  // this.size =&gt; the alphabet size
  if( this.size = size ) {
    for (i=0; i&lt;size; i++) {
      this.map[i] = 0;
    }
  }

  // this.esc  =&gt; the current tree height
  // this.root =&gt; the root of the tree
  this.esc = this.root = root;

  if (bitstream) {
    this.readBit = bitstream.readBit.bind(bitstream);
    this.writeBit = bitstream.writeBit.bind(bitstream);
  }
  this.max_weight = max_weight; // may be null or undefined
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Huffman.compressFile" id="apidoc.element.compressjs.Huffman.compressFile">
        function <span class="apidocSignatureSpan">compressjs.Huffman.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Huffman.decompressFile" id="apidoc.element.compressjs.Huffman.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.Huffman.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Huffman.factory" id="apidoc.element.compressjs.Huffman.factory">
        function <span class="apidocSignatureSpan">compressjs.Huffman.</span>factory
        <span class="apidocSignatureSpan">(bitstream, max_weight)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (bitstream, max_weight) {
  return function(size) {
    return new Huffman(size, size, bitstream, max_weight);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.Huffman.prototype" id="apidoc.module.compressjs.Huffman.prototype">module compressjs.Huffman.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.Huffman.prototype.decode" id="apidoc.element.compressjs.Huffman.prototype.decode">
        function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>decode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function () {
  var node = this.root;
  var symbol, down;

  //  work down the tree from the root
  //  until reaching either a leaf
  //  or the escape node.  A one
  //  bit means go left, a zero
  //  means go right.

  while( down = this.table[node].down ) {
    if( this.readBit() ) {
      node = down - 1;  // the left child precedes the right child
    } else {
      node = down;
    }
  }

  //  sent to the escape node???
  //  refuse to add to a full tree

  if( node === this.esc ) {
    if( this.esc ) {
      symbol = this.readid ();
      node = this.split (symbol);
    } else {
      console.assert(false);
      return 0;
    }
  } else {
    symbol = this.table[node].symbol;
  }

  //  increment weights and re-balance
  //  the coding tree

  this.increment (node);
  return symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var l = 4 + ((lgDistance-3)*2) + nextBit;
    this.lgDistanceModel.encode(l + this.extraStates);
    // now encode the rest of the bits.
    var rest = distance &amp; ((1 &lt;&lt; (lgDistance-2)) - 1);
    this.distanceModel[lgDistance].encode(rest);
};
DeflateDistanceModel.prototype.decode = function() {
    var l = this.lgDistanceModel.<span class="apidocCodeKeywordSpan">decode</span>() - this.extraStates;
    if (l &lt; 4) {
        return l; // this is a small distance or an 'extra state'
    }
    var nextBit = (l&amp;1);
    var lgDistance = ((l-4) &gt;&gt;&gt; 1) + 3;
    var rest = this.distanceModel[lgDistance].decode();
    return ((2+nextBit) &lt;&lt; (lgDistance-2)) + rest;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Huffman.prototype.encode" id="apidoc.element.compressjs.Huffman.prototype.encode">
        function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>encode
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (symbol) {
  var emit = 1, bit;
  var up, idx, node;

  if( symbol &lt; this.size ) {
    node = this.map[symbol];
  } else {
    console.assert(false);
    return;
  }

  //  for a new symbol, direct the receiver to the escape node
  //  but refuse input if table is already full.

  if( !(idx = node) ) {
    if( !(idx = this.esc) ) {
      return;
    }
  }

  //  accumulate the code bits by
  //  working up the tree from
  //  the node to the root

  while( up = this.table[idx].up ) {
    emit &lt;&lt;= 1; emit |= idx &amp; 1; idx = up;
  }

  //  send the code, root selector bit first

  while( bit = emit &amp; 1, emit &gt;&gt;= 1 ) {
    this.writeBit(bit);
  }

  //  send identification and incorporate
  //  new symbols into the tree

  if( !node ) {
    this.sendid(symbol);
    node = this.split(symbol);
  }

  //  adjust and re-balance the tree

  this.increment(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
};
/* you can give this model arguments between 0 and (size-1), or else
   a negative argument which is one of the 'extra states'. */
DeflateDistanceModel.prototype.encode = function(distance) {
    if (distance &lt; 4) { // small distance or an 'extra state'
        this.lgDistanceModel.<span class="apidocCodeKeywordSpan">encode</span>(distance + this.extraStates);
        return;
    }
    var lgDistance = Util.fls(distance);
    console.assert(distance &amp; (1&lt;&lt;(lgDistance-1))); // top bit is set
    console.assert(lgDistance &gt;= 3);
    var nextBit = (distance &amp; (1 &lt;&lt; (lgDistance-2))) ? 1 : 0;
    var l = 4 + ((lgDistance-3)*2) + nextBit;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Huffman.prototype.increment" id="apidoc.element.compressjs.Huffman.prototype.increment">
        function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>increment
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">increment = function (node) {
  var up;

  //  obviate swapping a parent with its child:
  //    increment the leaf and proceed
  //    directly to its parent.

  //  otherwise, promote leaf to group leader position in the tree

  if( this.table[node].up === node + 1 ) {
    this.table[node].weight += 2;
    node++;
  } else {
    node = this.leader (node);
  }

  //  increase the weight of each node and slide
  //  over any smaller weights ahead of it
  //  until reaching the root

  //  internal nodes work upwards from
  //  their initial positions; while
  //  symbol nodes slide over first,
  //  then work up from their final
  //  positions.

  while( this.table[node].weight += 2, up = this.table[node].up ) {
    while( this.table[node].weight &gt; this.table[node + 1].weight ) {
        node = this.slide (node);
    }

    if( this.table[node].weight &amp; 1 ) {
        node = up;
    } else {
        node = this.table[node].up;
    }
  }

<span class="apidocCodeCommentSpan">  /* Re-scale if necessary. */
</span>  if (this.max_weight) {
    if (this.table[this.root].weight &gt;= this.max_weight) {
      this.scale(1);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Huffman.prototype.leader" id="apidoc.element.compressjs.Huffman.prototype.leader">
        function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>leader
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leader = function (node) {
  var weight = this.table[node].weight;
  var leader = node, prev, symbol;

  while( weight === this.table[leader + 1].weight ) {
    leader++;
  }

  if( leader === node ) {
    return node;
  }

  // swap the leaf nodes

  symbol = this.table[node].symbol;
  prev = this.table[leader].symbol;

  this.table[leader].symbol = symbol;
  this.table[node].symbol = prev;
  this.map[symbol] = leader;
  this.map[prev] = node;
  return leader;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Huffman.prototype.readid" id="apidoc.element.compressjs.Huffman.prototype.readid">
        function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>readid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readid = function () {
  var empty = 0, bit = 1, max, symbol;

  //  receive the symbol, LSB first, reading
  //  only the number of bits necessary to
  //  transmit the maximum possible symbol value

  if( max = this.size - Math.floor((this.root - this.esc) / 2) - 1 ) {
    do {
      empty |= this.readBit() ? bit : 0;
      bit &lt;&lt;= 1;
    } while( max &gt;&gt;= 1 );
  }

  //  the count is of unmapped symbols
  //  in the table before the new one

  for( symbol = 0; symbol &lt; this.size; symbol++ ) {
    if( !this.map[symbol] ) {
      if( !empty-- ) {
        return symbol;
      }
    }
  }

  //  oops!  our count is too big, either due
  //  to a bit error, or a short node count
  //  given to huff_init.

  console.assert(false);
  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Huffman.prototype.scale" id="apidoc.element.compressjs.Huffman.prototype.scale">
        function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>scale
        <span class="apidocSignatureSpan">(bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scale = function (bits) {
  var node = this.esc, weight, prev;

  //  work up the tree from the escape node
  //  scaling weights by the value of bits

  while( ++node &lt;= this.root ) {
    //  recompute the weight of internal nodes;
    //  slide down and out any unused ones

    if( this.table[node].weight &amp; 1 ) {
      if( weight = this.table[this.table[node].down].weight &amp; ~1 ) {
        weight += this.table[this.table[node].down - 1].weight | 1;
      }

      //  remove zero weight leaves by incrementing HuffEsc
      //  and removing them from the symbol map.  take care

    } else if( !(weight = this.table[node].weight &gt;&gt; bits &amp; ~1) ) {
      if( this.map[this.table[node].symbol] = 0, this.esc++ ) {
        this.esc++;
      }
    }

    // slide the scaled node back down over any
    // previous nodes with larger weights

    this.table[node].weight = weight;
    prev = node;

    while( weight &lt; this.table[--prev].weight ) {
      this.slide(prev);
    }
  }

  // prepare a new escape node

  this.table[this.esc].down = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Huffman.prototype.sendid" id="apidoc.element.compressjs.Huffman.prototype.sendid">
        function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>sendid
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendid = function (symbol) {
  var empty = 0, max;

  //  count the number of empty symbols
  //  before the symbol in the table

  while( symbol-- ) {
    if( !this.map[symbol] ) {
      empty++;
    }
  }

  //  send LSB of this count first, using
  //  as many bits as are required for
  //  the maximum possible count

  if( max = this.size - Math.floor((this.root - this.esc) / 2) - 1 ) {
    do {
      this.writeBit(empty &amp; 1);
      empty &gt;&gt;= 1;
    } while( max &gt;&gt;= 1 );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Huffman.prototype.slide" id="apidoc.element.compressjs.Huffman.prototype.slide">
        function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>slide
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slide = function (node) {
  var next = node;
  var swap;

  swap = this.table[next++].clone();

  // if we're sliding an internal node, find the
  // highest possible leaf to exchange with

  if( swap.weight &amp; 1 ) {
    while( swap.weight &gt; this.table[next + 1].weight ) {
      next++;
    }
  }

  //  swap the two nodes

  this.table[node].set(this.table[next]);
  this.table[next].set(swap);

  this.table[next].up = this.table[node].up;
  this.table[node].up = swap.up;

  //  repair the symbol map and tree structure

  if( swap.weight &amp; 1 ) {
    this.table[swap.down].up = next;
    this.table[swap.down - 1].up = next;
    this.map[this.table[node].symbol] = node;
  } else {
    this.table[this.table[node].down - 1].up = node;
    this.table[this.table[node].down].up = node;
    this.map[swap.symbol] = next;
  }

  return next;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Huffman.prototype.split" id="apidoc.element.compressjs.Huffman.prototype.split">
        function <span class="apidocSignatureSpan">compressjs.Huffman.prototype.</span>split
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (symbol) {
  var pair, node;

  //  is the tree already full???

  if( pair = this.esc ) {
    this.esc--;
  } else {
    console.assert(false);
    return 0;
  }

  //  if this is the last symbol, it moves into
  //  the escape node's old position, and
  //  this.esc is set to zero.

  //  otherwise, the escape node is promoted to
  //  parent a new escape node and the new symbol.

  if( node = this.esc ) {
    this.table[pair].down = node;
    this.table[pair].weight = 1;
    this.table[node].up = pair;
    this.esc--;
  } else {
    pair = 0;
    node = 1;
  }

  //  initialize the new symbol node

  this.table[node].symbol = symbol;
  this.table[node].weight = 0;
  this.table[node].down = 0;
  this.map[symbol] = node;

  //  initialize a new escape node.

  this.table[this.esc].weight = 0;
  this.table[this.esc].down = 0;
  this.table[this.esc].up = pair;
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.HuffmanAllocator" id="apidoc.module.compressjs.HuffmanAllocator">module compressjs.HuffmanAllocator</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.HuffmanAllocator.allocateHuffmanCodeLengths" id="apidoc.element.compressjs.HuffmanAllocator.allocateHuffmanCodeLengths">
        function <span class="apidocSignatureSpan">compressjs.HuffmanAllocator.</span>allocateHuffmanCodeLengths
        <span class="apidocSignatureSpan">(array, maximumLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocateHuffmanCodeLengths = function (array, maximumLength) {
  switch (array.length) {
  case 2:
    array[1] = 1;
  case 1:
    array[0] = 1;
    return;
  }

<span class="apidocCodeCommentSpan">  /* Pass 1 : Set extended parent pointers */
</span>  setExtendedParentPointers (array);

  /* Pass 2 : Find number of nodes to relocate in order to achieve
   *          maximum code length */
  var nodesToRelocate = findNodesToRelocate (array, maximumLength);

  /* Pass 3 : Generate code lengths */
  if ((array[0] % array.length) &gt;= nodesToRelocate) {
    allocateNodeLengths (array);
  } else {
    var insertDepth = maximumLength - (Util.fls(nodesToRelocate - 1));
    allocateNodeLengthsWithRelocation (array, nodesToRelocate, insertDepth);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.LogDistanceModel" id="apidoc.module.compressjs.LogDistanceModel">module compressjs.LogDistanceModel</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.LogDistanceModel.LogDistanceModel" id="apidoc.element.compressjs.LogDistanceModel.LogDistanceModel">
        function <span class="apidocSignatureSpan">compressjs.</span>LogDistanceModel
        <span class="apidocSignatureSpan">(size, extraStates, lgDistanceModelFactory, lengthBitsModelFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LogDistanceModel = function (size, extraStates, lgDistanceModelFactory, lengthBitsModelFactory) {
    var i;
    var bits = Util.fls(size-1);
    this.extraStates = +extraStates || 0;
    this.lgDistanceModel = lgDistanceModelFactory(1 + bits + extraStates);
    // this.distanceModel[n] used for distances which are n-bits long,
    // but only n-1 bits are encoded: the top bit is known to be one.
    this.distanceModel = [];
    for (i=2 ; i &lt;= bits; i++) {
        var numBits = i - 1;
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.LogDistanceModel.prototype" id="apidoc.module.compressjs.LogDistanceModel.prototype">module compressjs.LogDistanceModel.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.LogDistanceModel.prototype.decode" id="apidoc.element.compressjs.LogDistanceModel.prototype.decode">
        function <span class="apidocSignatureSpan">compressjs.LogDistanceModel.prototype.</span>decode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function () {
    var lgDistance = this.lgDistanceModel.decode() - this.extraStates;
    if (lgDistance &lt; 2) {
        return lgDistance; // this is a small distance or an 'extra state'
    }
    var rest = this.distanceModel[lgDistance].decode();
    return (1 &lt;&lt; (lgDistance-1)) + rest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var l = 4 + ((lgDistance-3)*2) + nextBit;
    this.lgDistanceModel.encode(l + this.extraStates);
    // now encode the rest of the bits.
    var rest = distance &amp; ((1 &lt;&lt; (lgDistance-2)) - 1);
    this.distanceModel[lgDistance].encode(rest);
};
DeflateDistanceModel.prototype.decode = function() {
    var l = this.lgDistanceModel.<span class="apidocCodeKeywordSpan">decode</span>() - this.extraStates;
    if (l &lt; 4) {
        return l; // this is a small distance or an 'extra state'
    }
    var nextBit = (l&amp;1);
    var lgDistance = ((l-4) &gt;&gt;&gt; 1) + 3;
    var rest = this.distanceModel[lgDistance].decode();
    return ((2+nextBit) &lt;&lt; (lgDistance-2)) + rest;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.LogDistanceModel.prototype.encode" id="apidoc.element.compressjs.LogDistanceModel.prototype.encode">
        function <span class="apidocSignatureSpan">compressjs.LogDistanceModel.prototype.</span>encode
        <span class="apidocSignatureSpan">(distance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (distance) {
    if (distance &lt; 2) { // small distance or an 'extra state'
        this.lgDistanceModel.encode(distance + this.extraStates);
        return;
    }
    var lgDistance = Util.fls(distance);
    console.assert(distance &amp; (1&lt;&lt;(lgDistance-1))); // top bit is set
    console.assert(lgDistance &gt;= 2);
    this.lgDistanceModel.encode(lgDistance + this.extraStates);
    // now encode the rest of the bits.
    var rest = distance &amp; ((1 &lt;&lt; (lgDistance-1)) - 1);
    this.distanceModel[lgDistance].encode(rest);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
};
/* you can give this model arguments between 0 and (size-1), or else
   a negative argument which is one of the 'extra states'. */
DeflateDistanceModel.prototype.encode = function(distance) {
    if (distance &lt; 4) { // small distance or an 'extra state'
        this.lgDistanceModel.<span class="apidocCodeKeywordSpan">encode</span>(distance + this.extraStates);
        return;
    }
    var lgDistance = Util.fls(distance);
    console.assert(distance &amp; (1&lt;&lt;(lgDistance-1))); // top bit is set
    console.assert(lgDistance &gt;= 3);
    var nextBit = (distance &amp; (1 &lt;&lt; (lgDistance-2))) ? 1 : 0;
    var l = 4 + ((lgDistance-3)*2) + nextBit;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.Lzjb" id="apidoc.module.compressjs.Lzjb">module compressjs.Lzjb</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.Lzjb.compressFile" id="apidoc.element.compressjs.Lzjb.compressFile">
        function <span class="apidocSignatureSpan">compressjs.Lzjb.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Lzjb.decompressFile" id="apidoc.element.compressjs.Lzjb.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.Lzjb.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.LzjbR" id="apidoc.module.compressjs.LzjbR">module compressjs.LzjbR</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.LzjbR.compressFile" id="apidoc.element.compressjs.LzjbR.compressFile">
        function <span class="apidocSignatureSpan">compressjs.LzjbR.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.LzjbR.decompressFile" id="apidoc.element.compressjs.LzjbR.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.LzjbR.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.Lzp3" id="apidoc.module.compressjs.Lzp3">module compressjs.Lzp3</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.Lzp3.compressFile" id="apidoc.element.compressjs.Lzp3.compressFile">
        function <span class="apidocSignatureSpan">compressjs.Lzp3.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Lzp3.decompressFile" id="apidoc.element.compressjs.Lzp3.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.Lzp3.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.MTFModel" id="apidoc.module.compressjs.MTFModel">module compressjs.MTFModel</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.MTFModel.MTFModel" id="apidoc.element.compressjs.MTFModel.MTFModel">
        function <span class="apidocSignatureSpan">compressjs.</span>MTFModel
        <span class="apidocSignatureSpan">(coder, size, max_prob, increment, betterEscape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MTFModel = function (coder, size, max_prob, increment, betterEscape) {
    this.coder = coder;
    this.increment = (+increment) || DEFAULT_INCREMENT;
    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;
    console.assert((this.max_prob + (this.increment-1)) &lt;= 0xFFFF);
    this.sym = Util.makeU16Buffer(size+1);
    this.prob= Util.makeU16Buffer(size+2);
    this.sym[0] = size; // escape code
    this.prob[0]= 0;
    this.seenSyms = 1;
    // total probability always found in this.prob[this.seenSyms]
    this.prob[this.seenSyms] = this.increment;
    this.numSyms = size;
    if (betterEscape) {
        this.sortedSeen = [size];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.MTFModel.compressFile" id="apidoc.element.compressjs.MTFModel.compressFile">
        function <span class="apidocSignatureSpan">compressjs.MTFModel.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.MTFModel.decompressFile" id="apidoc.element.compressjs.MTFModel.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.MTFModel.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.MTFModel.factory" id="apidoc.element.compressjs.MTFModel.factory">
        function <span class="apidocSignatureSpan">compressjs.MTFModel.</span>factory
        <span class="apidocSignatureSpan">(coder, max_prob, increment, betterEscape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (coder, max_prob, increment, betterEscape) {
    return function(size) {
        return new MTFModel(coder, size, max_prob, increment, betterEscape);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.MTFModel.prototype" id="apidoc.module.compressjs.MTFModel.prototype">module compressjs.MTFModel.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.MTFModel.prototype._rescale" id="apidoc.element.compressjs.MTFModel.prototype._rescale">
        function <span class="apidocSignatureSpan">compressjs.MTFModel.prototype.</span>_rescale
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_rescale = function () {
    var i, j, total=0;
    var noEscape = true;
    if (this.sortedSeen) { this.sortedSeen.length = 0; }
    for(i=0, j=0; i&lt;this.seenSyms; i++) {
        var sym = this.sym[i];
        var sy_f = this.prob[i+1] - this.prob[i];
        sy_f &gt;&gt;&gt;= 1;
        if (sy_f &gt; 0) {
            if (sym === this.numSyms) {
                noEscape = false;
            }
            this.sym[j] = sym;
            this.prob[j++] = total;
            total += sy_f;
            if (this.sortedSeen) { this.sortedSeen.push(sym); }
        }
    }
    this.prob[j] = total;
    this.seenSyms = j;
    if (this.sortedSeen) {
        this.sortedSeen.sort(NUMERIC_SORT);
    }
    // don't allow escape to go to zero prob if we still need it
    if (noEscape &amp;&amp; this.seenSyms &lt; this.numSyms) {
        // NOTE this adds this.increment to escape freq; the FenwickModel
        //      just adds one.
        this._update(this.numSyms/*escape*/, this.seenSyms/*at end*/);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.MTFModel.prototype._update" id="apidoc.element.compressjs.MTFModel.prototype._update">
        function <span class="apidocSignatureSpan">compressjs.MTFModel.prototype.</span>_update
        <span class="apidocSignatureSpan">(symbol, index, sy_f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_update = function (symbol, index, sy_f) {
    var j, tot_f;
    // move this symbol to the end
    for (j=index; j&lt;this.seenSyms-1; j++) {
        this.sym[j] = this.sym[j+1];
        this.prob[j] = this.prob[j+1] - sy_f;
    }
    if (index &lt; this.seenSyms) {
        this.sym[j] = symbol;
        this.prob[j] = this.prob[j+1] - sy_f;
        // increase frequency for this symbol, and total freq at same time
        this.prob[this.seenSyms] = tot_f =
            this.prob[this.seenSyms] + this.increment;
        if (symbol === this.numSyms &amp;&amp; this.seenSyms &gt;= this.numSyms) {
            // this is the last time we'll see an escape! remove it.
            tot_f = this.prob[--this.seenSyms];
            if (this.sortedSeen) { this.sortedSeen.length--; }
        }
    } else { // add to the end
        tot_f = this.prob[this.seenSyms];
        this.sym[index] = symbol;
        this.prob[index] = tot_f;
        tot_f += this.increment;
        this.prob[++this.seenSyms] = tot_f;
        if (this.sortedSeen) {
            this.sortedSeen.push(symbol);
            // hopefully sort is very fast on a mostly-sorted array
            this.sortedSeen.sort(NUMERIC_SORT);
        }
    }
    if (tot_f &gt;= this.max_prob) { this._rescale(); }
    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.MTFModel.prototype.clone" id="apidoc.element.compressjs.MTFModel.prototype.clone">
        function <span class="apidocSignatureSpan">compressjs.MTFModel.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
    var newModel = new MTFModel(this.coder, this.numSyms, this.max_prob,
                                this.increment, !!this.sortedSeen);
    var i;
    for (i=0; i&lt;this.seenSyms; i++) {
        newModel.sym[i] = this.sym[i];
        newModel.prob[i] = this.prob[i];
    }
    newModel.prob[i] = this.prob[i]; // total probability
    newModel.seenSyms = this.seenSyms;
    if (this.sortedSeen) {
        newModel.sortedSeen = this.sortedSeen.slice(0);
    }
    return newModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.MTFModel.prototype.decode" id="apidoc.element.compressjs.MTFModel.prototype.decode">
        function <span class="apidocSignatureSpan">compressjs.MTFModel.prototype.</span>decode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function () {
    var tot_f = this.prob[this.seenSyms];
    var prob = this.coder.decodeCulFreq(tot_f);
    // we're expecting to find the probability near the "most recent" side
    // of our array
    var i;
    for (i=this.seenSyms-1; i&gt;=0; i--) {
        if (this.prob[i] &lt;= prob<span class="apidocCodeCommentSpan"> /*&amp;&amp; prob &lt; this.prob[i+1]*/)
            break;
    }
    console.assert(i&gt;=0);
    var symbol = this.sym[i];
    var lt_f = this.prob[i];
    var sy_f = this.prob[i + 1] - lt_f;
    this.coder.decodeUpdate(sy_f, lt_f, tot_f);
    this._update(symbol, i, sy_f);
    if (symbol === this.numSyms) {
        /* this is an escape */
</span>        /* decode the literal */
        sy_f = 1;
        tot_f = this.numSyms;
        if (this.sortedSeen) {
            // do a slower, but more precise decoding of the literal
            // by excluding the already-seen symbols.
            var seen = this.sortedSeen;
            tot_f = this.numSyms - this.seenSyms;
            if (seen[seen.length-1] === this.numSyms) { tot_f++; }
            symbol = lt_f = this.coder.decodeCulFreq(tot_f);
            for (i=0; i &lt; seen.length &amp;&amp; seen[i] &lt;= symbol ; i++) {
                symbol++;
            }
        } else {
            symbol = lt_f = this.coder.decodeCulFreq(tot_f);
        }
        this.coder.decodeUpdate(sy_f, lt_f, tot_f);
        this._update(symbol, this.seenSyms);
    }
    return symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var l = 4 + ((lgDistance-3)*2) + nextBit;
    this.lgDistanceModel.encode(l + this.extraStates);
    // now encode the rest of the bits.
    var rest = distance &amp; ((1 &lt;&lt; (lgDistance-2)) - 1);
    this.distanceModel[lgDistance].encode(rest);
};
DeflateDistanceModel.prototype.decode = function() {
    var l = this.lgDistanceModel.<span class="apidocCodeKeywordSpan">decode</span>() - this.extraStates;
    if (l &lt; 4) {
        return l; // this is a small distance or an 'extra state'
    }
    var nextBit = (l&amp;1);
    var lgDistance = ((l-4) &gt;&gt;&gt; 1) + 3;
    var rest = this.distanceModel[lgDistance].decode();
    return ((2+nextBit) &lt;&lt; (lgDistance-2)) + rest;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.MTFModel.prototype.encode" id="apidoc.element.compressjs.MTFModel.prototype.encode">
        function <span class="apidocSignatureSpan">compressjs.MTFModel.prototype.</span>encode
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (symbol) {
    // look for symbol, from most-recent to oldest
    var i, sy_f, lt_f, tot_f;
    for (i=this.seenSyms-1; i&gt;=0; i--) {
        if (symbol === this.sym[i]) {
            // ok, found it.
            lt_f = this.prob[i];
            sy_f = this.prob[i + 1] - lt_f;
            tot_f = this.prob[this.seenSyms];
            this.coder.encodeFreq(sy_f, lt_f, tot_f);
            return this._update(symbol, i, sy_f);
        }
    }
    // couldn't find this symbol.  encode as escape.
    console.assert(symbol !== this.numSyms); // catch infinite recursion
    this.encode(this.numSyms); // guaranteed to be found in the table.
    // code symbol as literal
    sy_f = 1;
    lt_f = symbol;
    tot_f = this.numSyms;
    if (this.sortedSeen) {
        // do a slower, but more precise encoding of the literal
        // by excluding the already-seen symbols.
        var seen = this.sortedSeen;
        tot_f -= this.seenSyms;
        if (seen[seen.length-1] === this.numSyms) { tot_f++; }
        for (i=0; i &lt; seen.length &amp;&amp; seen[i] &lt; symbol; i++) {
            lt_f--;
        }
    }
    this.coder.encodeFreq(sy_f, lt_f, tot_f);
    // now add symbol to the end.
    return this._update(symbol, this.seenSyms);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
};
/* you can give this model arguments between 0 and (size-1), or else
   a negative argument which is one of the 'extra states'. */
DeflateDistanceModel.prototype.encode = function(distance) {
    if (distance &lt; 4) { // small distance or an 'extra state'
        this.lgDistanceModel.<span class="apidocCodeKeywordSpan">encode</span>(distance + this.extraStates);
        return;
    }
    var lgDistance = Util.fls(distance);
    console.assert(distance &amp; (1&lt;&lt;(lgDistance-1))); // top bit is set
    console.assert(lgDistance &gt;= 3);
    var nextBit = (distance &amp; (1 &lt;&lt; (lgDistance-2))) ? 1 : 0;
    var l = 4 + ((lgDistance-3)*2) + nextBit;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.NoModel" id="apidoc.module.compressjs.NoModel">module compressjs.NoModel</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.NoModel.NoModel" id="apidoc.element.compressjs.NoModel.NoModel">
        function <span class="apidocSignatureSpan">compressjs.</span>NoModel
        <span class="apidocSignatureSpan">(bitstream, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NoModel = function (bitstream, size) {
  this.bitstream = bitstream;
  this.bits = Util.fls(size-1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.NoModel.compressFile" id="apidoc.element.compressjs.NoModel.compressFile">
        function <span class="apidocSignatureSpan">compressjs.NoModel.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.NoModel.decompressFile" id="apidoc.element.compressjs.NoModel.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.NoModel.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.NoModel.factory" id="apidoc.element.compressjs.NoModel.factory">
        function <span class="apidocSignatureSpan">compressjs.NoModel.</span>factory
        <span class="apidocSignatureSpan">(bitstream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (bitstream) {
  return function(size) { return new NoModel(bitstream, size); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.NoModel.prototype" id="apidoc.module.compressjs.NoModel.prototype">module compressjs.NoModel.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.NoModel.prototype.decode" id="apidoc.element.compressjs.NoModel.prototype.decode">
        function <span class="apidocSignatureSpan">compressjs.NoModel.prototype.</span>decode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function () {
  var i, r = 0;
  for (i=this.bits-1; i&gt;=0; i--) {
    r &lt;&lt;= 1;
    if (this.bitstream.readBit()) r++;
  }
  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var l = 4 + ((lgDistance-3)*2) + nextBit;
    this.lgDistanceModel.encode(l + this.extraStates);
    // now encode the rest of the bits.
    var rest = distance &amp; ((1 &lt;&lt; (lgDistance-2)) - 1);
    this.distanceModel[lgDistance].encode(rest);
};
DeflateDistanceModel.prototype.decode = function() {
    var l = this.lgDistanceModel.<span class="apidocCodeKeywordSpan">decode</span>() - this.extraStates;
    if (l &lt; 4) {
        return l; // this is a small distance or an 'extra state'
    }
    var nextBit = (l&amp;1);
    var lgDistance = ((l-4) &gt;&gt;&gt; 1) + 3;
    var rest = this.distanceModel[lgDistance].decode();
    return ((2+nextBit) &lt;&lt; (lgDistance-2)) + rest;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.NoModel.prototype.encode" id="apidoc.element.compressjs.NoModel.prototype.encode">
        function <span class="apidocSignatureSpan">compressjs.NoModel.prototype.</span>encode
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (symbol) {
  var i;
  for (i=this.bits-1; i&gt;=0; i--) {
    var b = (symbol &gt;&gt;&gt; i) &amp; 1;
    this.bitstream.writeBit(b);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
};
/* you can give this model arguments between 0 and (size-1), or else
   a negative argument which is one of the 'extra states'. */
DeflateDistanceModel.prototype.encode = function(distance) {
    if (distance &lt; 4) { // small distance or an 'extra state'
        this.lgDistanceModel.<span class="apidocCodeKeywordSpan">encode</span>(distance + this.extraStates);
        return;
    }
    var lgDistance = Util.fls(distance);
    console.assert(distance &amp; (1&lt;&lt;(lgDistance-1))); // top bit is set
    console.assert(lgDistance &gt;= 3);
    var nextBit = (distance &amp; (1 &lt;&lt; (lgDistance-2))) ? 1 : 0;
    var l = 4 + ((lgDistance-3)*2) + nextBit;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.PPM" id="apidoc.module.compressjs.PPM">module compressjs.PPM</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.PPM.PPM" id="apidoc.element.compressjs.PPM.PPM">
        function <span class="apidocSignatureSpan">compressjs.</span>PPM
        <span class="apidocSignatureSpan">(coder, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PPM = function (coder, size) {
  this.window = new Window();
  this.contexts = Object.create(null);
  // brain-dead '-1' context, using full exclusion
  var Cm1Context = function() { };
  Cm1Context.prototype.encode = function(symbol, exclude) {
    var i, lt_f = 0;
    for (i=0; i&lt;symbol; i++) {
      if (!exclude[i]) {
        lt_f++;
      }
    }
    var tot_f = size - exclude.total;
    coder.encodeFreq(1, lt_f, tot_f);
  };
  Cm1Context.prototype.decode = function(exclude) {
    var i, symbol, lt_f;
    var tot_f = size - exclude.total;
    symbol = lt_f = coder.decodeCulFreq(tot_f);
    for (i=0; i&lt;=symbol; i++) {
      if (exclude[i]) {
        symbol++;
      }
    }
    coder.decodeUpdate(1, lt_f, tot_f);
    return symbol;
  };
  this.cm1coder = new Cm1Context();

  var DenseMTFModel = function() {
    this.sym = [size];
    this.prob= [0, DMM_INCREMENT];
    this.refcount = 0;
  };
  DenseMTFModel.prototype._rescale = function() {
    var seenSyms = this.sym.length;
    var i, j, total=0;
    var noEscape = true;
    for(i=0, j=0; i&lt;seenSyms; i++) {
      var sym = this.sym[i];
      var sy_f = this.prob[i+1] - this.prob[i];
      sy_f &gt;&gt;&gt;= 1;
      if (sy_f &gt; 0) {
        if (sym === size) {
          noEscape = false;
        }
        this.sym[j] = sym;
        this.prob[j++] = total;
        total += sy_f;
      }
    }
    this.prob[j] = total;
    seenSyms = this.sym.length = j;
    this.prob.length = seenSyms + 1;
    // don't allow escape to go to zero prob if we still need it
    if (noEscape &amp;&amp; seenSyms &lt; size) {
      total = this._update(size/*escape*/, seenSyms/*at end*/, 0, 1);
    }
    return total;
  };
  DenseMTFModel.prototype.update = function(symbol, incr) {
    // find symbol
    var i=0;
    for (i=0; i&lt;this.sym.length; i++) {
      if (this.sym[i] === symbol) {
        return this._update(symbol, i, this.prob[i+1] - this.prob[i], incr);
      }
    }
    // symbol escaped
    return this._update(symbol, i, 0, incr);
  };
  DenseMTFModel.prototype._update = function(symbol, index, sy_f, incr) {
    var seenSyms = this.sym.length;
    var i, j, tot_f;
    // move this symbol to the end
    for (j=index; j&lt;seenSyms-1; j++) {
      this.sym[j] = this.sym[j+1];
      this.prob[j] = this.prob[j+1] - sy_f;
    }
    // "method D" -- if we add a new escaped symbol, escape &amp; the symbol
    // both increase by 1/2.
    if (index &lt; seenSyms) {
      this.sym[j] = symbol;
      this.prob[j] = this.prob[j+1] - sy_f;
      // increase frequency for this symbol, and total freq at same time
      this.prob[seenSyms] = tot_f =
        this.prob[seenSyms] + incr;
    } else { // add to the end
      tot_f = this.prob[seenSyms];
      this.sym[index] = symbol;
      this.prob[index] = tot_f;
      tot_f += incr;
      this.prob[++seenSyms] = tot_f;
      // remove probability of escape if table just filled up
      if (this.sym.length &gt; size) {
        for (i=0; i&lt;seenSyms; i++) {
          if (size === this.sym[i]) {
            // found it.
            this._update(size, i, this.prob[i+1] - this.prob[i], -1);
            this.sym.length--;
            this.prob.length--;
            tot_f = this.prob[this.prob.length-1];
          }
        }
      }
    }
    if (tot_f &gt;= DMM_MAX_PROB) { tot_f = this._rescale(); }
    return tot_f;
  };
  DenseMTFModel.prototype.encode = function(symbol, exclude) {
    // look for symbol, from most-recent to oldest
    var i, j, sy_f, lt_f, tot_f, seenSyms = this.sym.length;
    var ex_seen = 0, ex_lt_f = 0, ex_tot_f = 0, ex_sy_f;
    for (i=seenSyms-1; i&gt;=0; i--) {
      lt_f = this.prob[i];
      sy_f = this.prob[i + 1] - lt_f;
      if (symbol === this.sym[i]) {
        // ok, found it.
        // count up the rest of the probabilities
        for (j=i-1; j&gt;=0 &amp;&amp; ex_seen &lt; exclude.total; j--) {
          if (exclude[this.sym[j]]) {
            ex_seen += 1;
            ex_sy_f = this.prob[j+1] - this.prob[j];
            ex_lt_f += ex_sy_f;
            ex_tot_f += ex_sy_f;
          }
        }
        tot_f = this.prob[seenSyms];
        // adjust by excluded symbols ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.PPM.compressFile" id="apidoc.element.compressjs.PPM.compressFile">
        function <span class="apidocSignatureSpan">compressjs.PPM.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.PPM.decompressFile" id="apidoc.element.compressjs.PPM.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.PPM.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.PPM.prototype" id="apidoc.module.compressjs.PPM.prototype">module compressjs.PPM.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.PPM.prototype.decode" id="apidoc.element.compressjs.PPM.prototype.decode">
        function <span class="apidocSignatureSpan">compressjs.PPM.prototype.</span>decode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function () {
  var contextString = this.window.context(this.window.pos, MAX_CONTEXT);
  var exclude = this.newExclude();
  var model, c, cc, symbol;
  for (c=MAX_CONTEXT; c&gt;=0; c--) {
    cc = contextString.slice(MAX_CONTEXT - c);
    model = this.contexts[cc];
    if (model) {
      symbol = model.decode(exclude);
      if (symbol &gt;= 0) {
        this.update(symbol, contextString, c);
        return symbol;
      }
    }
  }
  // still no match, fall back to context -1
  symbol = this.cm1coder.decode(exclude);
  this.update(symbol, contextString, c);
  return symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var l = 4 + ((lgDistance-3)*2) + nextBit;
    this.lgDistanceModel.encode(l + this.extraStates);
    // now encode the rest of the bits.
    var rest = distance &amp; ((1 &lt;&lt; (lgDistance-2)) - 1);
    this.distanceModel[lgDistance].encode(rest);
};
DeflateDistanceModel.prototype.decode = function() {
    var l = this.lgDistanceModel.<span class="apidocCodeKeywordSpan">decode</span>() - this.extraStates;
    if (l &lt; 4) {
        return l; // this is a small distance or an 'extra state'
    }
    var nextBit = (l&amp;1);
    var lgDistance = ((l-4) &gt;&gt;&gt; 1) + 3;
    var rest = this.distanceModel[lgDistance].decode();
    return ((2+nextBit) &lt;&lt; (lgDistance-2)) + rest;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.PPM.prototype.encode" id="apidoc.element.compressjs.PPM.prototype.encode">
        function <span class="apidocSignatureSpan">compressjs.PPM.prototype.</span>encode
        <span class="apidocSignatureSpan">(symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (symbol) {
  var contextString = this.window.context(this.window.pos, MAX_CONTEXT);
  var exclude = this.newExclude();
  var c;
  for (c=MAX_CONTEXT; c&gt;=0; c--) {
    var cc = contextString.slice(MAX_CONTEXT - c);
    var model = this.contexts[cc];
    if (model) {
      var success = model.encode(symbol, exclude);
      if (success) {
        this.update(symbol, contextString, c);
        return;
      }
    }
  }
  // fall back to context -1 (but still use exclusion table)
  this.cm1coder.encode(symbol, exclude);
  this.update(symbol, contextString, c);
  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.distanceModel[i] = lengthBitsModelFactory(1&lt;&lt;numBits);
    }
};
/* you can give this model arguments between 0 and (size-1), or else
   a negative argument which is one of the 'extra states'. */
DeflateDistanceModel.prototype.encode = function(distance) {
    if (distance &lt; 4) { // small distance or an 'extra state'
        this.lgDistanceModel.<span class="apidocCodeKeywordSpan">encode</span>(distance + this.extraStates);
        return;
    }
    var lgDistance = Util.fls(distance);
    console.assert(distance &amp; (1&lt;&lt;(lgDistance-1))); // top bit is set
    console.assert(lgDistance &gt;= 3);
    var nextBit = (distance &amp; (1 &lt;&lt; (lgDistance-2))) ? 1 : 0;
    var l = 4 + ((lgDistance-3)*2) + nextBit;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.PPM.prototype.update" id="apidoc.element.compressjs.PPM.prototype.update">
        function <span class="apidocSignatureSpan">compressjs.PPM.prototype.</span>update
        <span class="apidocSignatureSpan">(symbol, contextString, matchLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (symbol, contextString, matchLevel) {
  // slide up the contexts, updating them
  var model, c, cc;
  for (c=0; c &lt;= MAX_CONTEXT; c++) {
    cc = contextString.slice(MAX_CONTEXT - c);
    model = this.contexts[cc];
    if (!model) {
      model = this.contexts[cc] = this.newContext();
    }
    if (c &gt;= matchLevel) {
      // only update useful contexts
      model.update(symbol, DMM_INCREMENT / 2);
    }
    // refcount all contexts, whether used/updated or not
    model.refcount++;
  }
  // now garbage-collect old contexts
  contextString = this.window.context(this.window.pos + MAX_CONTEXT,
                                      MAX_CONTEXT);
  var firstPass = this.window.firstPass;
  for (c=MAX_CONTEXT; c&gt;=0 &amp;&amp; !firstPass; c--) {
    cc = contextString.slice(0, c);
    model = this.contexts[cc];
    console.assert(model);
    if ((--model.refcount) &lt;= 0) {
      console.assert(cc !== ''); // don't allow context-0 to be gc'ed!
      delete this.contexts[cc];
    }
  }
  // ok, advance window.
  this.window.put(symbol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.RangeCoder" id="apidoc.module.compressjs.RangeCoder">module compressjs.RangeCoder</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.RangeCoder" id="apidoc.element.compressjs.RangeCoder.RangeCoder">
        function <span class="apidocSignatureSpan">compressjs.</span>RangeCoder
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RangeCoder = function (stream) {
    this.low = 0;<span class="apidocCodeCommentSpan"> /* low end of interval */
</span>    this.range = Top_value; /* length of interval */
    this.buffer = 0; /* buffer for input/output */
    this.help = 0; /* bytes_to_follow / intermediate value */
    this.bytecount = 0; /* counter for output bytes */
    this.stream = stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.RangeCoder.prototype" id="apidoc.module.compressjs.RangeCoder.prototype">module compressjs.RangeCoder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.decodeBit" id="apidoc.element.compressjs.RangeCoder.prototype.decodeBit">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeBit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeBit = function () {
    var tmp = this.decodeCulShift(1);
    this.decodeUpdate(1, tmp, 1&lt;&lt;1);
    return tmp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.decodeByte" id="apidoc.element.compressjs.RangeCoder.prototype.decodeByte">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeByte
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeByte = function () {
    var tmp = this.decodeCulShift(8);
    this.decodeUpdate(1, tmp, 1&lt;&lt;8);
    return tmp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.decodeCulFreq" id="apidoc.element.compressjs.RangeCoder.prototype.decodeCulFreq">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeCulFreq
        <span class="apidocSignatureSpan">(tot_f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeCulFreq = function (tot_f) {
    dec_normalize(this, this.stream);
    this.help = (this.range / tot_f) &gt;&gt;&gt; 0; // note coercion to integer
    var tmp = (this.low / this.help) &gt;&gt;&gt; 0; // again
    return (tmp &gt;= tot_f ? tot_f-1 : tmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (tot_f !== this.tot_f) {
        console.error('decodeCul* wrong total: got', tot_f,
                      'expected', this.tot_f);
    }
    return (this.sy_f&gt;&gt;&gt;1) + this.lt_f;
};
Dummy.prototype.decodeCulShift = function(shift) {
    return this.<span class="apidocCodeKeywordSpan">decodeCulFreq</span>(1&lt;&lt;shift);
};
Dummy.prototype.decodeUpdate = function(sy_f, lt_f, tot_f) {
    console.assert(sy_f &gt; 0);
    console.assert(tot_f &gt; 0);
    if (sy_f !== this.sy_f ||
        lt_f !== this.lt_f ||
        tot_f!== this.tot_f) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.decodeCulShift" id="apidoc.element.compressjs.RangeCoder.prototype.decodeCulShift">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeCulShift
        <span class="apidocSignatureSpan">(shift)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeCulShift = function (shift) {
    dec_normalize(this, this.stream);
    this.help = this.range &gt;&gt;&gt; shift;
    var tmp = (this.low / this.help) &gt;&gt;&gt; 0; // coercion to unsigned
    // shift is less than 31, so shift below will remain positive
    return ((tmp&gt;&gt;&gt;shift) ? (1&lt;&lt;shift)-1 : tmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.decodeFinish" id="apidoc.element.compressjs.RangeCoder.prototype.decodeFinish">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeFinish
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeFinish = function () {
<span class="apidocCodeCommentSpan">    /* normalize to use up all bytes */
</span>    dec_normalize(this, this.stream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.decodeShort" id="apidoc.element.compressjs.RangeCoder.prototype.decodeShort">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeShort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeShort = function () {
    var tmp = this.decodeCulShift(16);
    this.decodeUpdate(1, tmp, 1&lt;&lt;16);
    return tmp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.decodeStart" id="apidoc.element.compressjs.RangeCoder.prototype.decodeStart">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeStart
        <span class="apidocSignatureSpan">(skipInitialRead)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeStart = function (skipInitialRead) {
    var c = skipInitialRead ? 0 : this.stream.readByte();
    if (typeof(c) !== 'number' || c &lt; 0) {
        return c; // EOF
    }
    this.buffer = this.stream.readByte();
    this.low = this.buffer &gt;&gt;&gt; (8 - EXTRA_BITS);
    this.range = 1 &lt;&lt; EXTRA_BITS;
    return c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.decodeUpdate" id="apidoc.element.compressjs.RangeCoder.prototype.decodeUpdate">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>decodeUpdate
        <span class="apidocSignatureSpan">(sy_f, lt_f, tot_f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeUpdate = function (sy_f, lt_f, tot_f) {
    var tmp = this.help * lt_f; // should not overflow!
    this.low -= tmp;
    if (lt_f + sy_f &lt; tot_f) {
        this.range = (this.help * sy_f);
    } else {
        this.range -= tmp;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.encodeBit" id="apidoc.element.compressjs.RangeCoder.prototype.encodeBit">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeBit
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeBit = function (b) {
    this.encodeShift(1, b?1:0, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.encodeByte" id="apidoc.element.compressjs.RangeCoder.prototype.encodeByte">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeByte
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeByte = function (b) {
    this.encodeShift(1, b, 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.encodeFinish" id="apidoc.element.compressjs.RangeCoder.prototype.encodeFinish">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeFinish
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeFinish = function () {
    var outputStream = this.stream;
    enc_normalize(this, outputStream);
    this.bytecount += 5;
    var tmp = this.low &gt;&gt;&gt; SHIFT_BITS;
    if ((this.low &amp; (Bottom_value-1)) &gt;= ((this.bytecount&amp;0xFFFFFF)&gt;&gt;&gt;1)) {
        tmp++;
    }
    if (tmp &gt; 0xFF) {<span class="apidocCodeCommentSpan"> /* we have a carry */
</span>        outputStream.writeByte(this.buffer + 1);
        for (; this.help; this.help--)
            outputStream.writeByte(0x00);
    } else { /* no carry */
        outputStream.writeByte(this.buffer);
        for (; this.help; this.help--)
            outputStream.writeByte(0xFF);
    }
    outputStream.writeByte(tmp &amp; 0xFF);
    // XXX: i'm pretty sure these could be three arbitrary bytes
    //      they are consumed by the decoder at the end
    outputStream.writeByte((this.bytecount &gt;&gt;&gt; 16) &amp; 0xFF);
    outputStream.writeByte((this.bytecount &gt;&gt;&gt;  8) &amp; 0xFF);
    outputStream.writeByte((this.bytecount       ) &amp; 0xFF);
    return this.bytecount;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.encodeFreq" id="apidoc.element.compressjs.RangeCoder.prototype.encodeFreq">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeFreq
        <span class="apidocSignatureSpan">(sy_f, lt_f, tot_f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeFreq = function (sy_f, lt_f, tot_f) {
    enc_normalize(this, this.stream);
    var r = (this.range / tot_f) &gt;&gt;&gt; 0; // note coercion to integer
    var tmp = r * lt_f;
    this.low += tmp;
    if ((lt_f + sy_f) &lt; tot_f) {
        this.range = r * sy_f;
    } else {
        this.range -= tmp;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                      sy_f, lt_f, tot_f);
    }
    Util.writeUnsignedNumber(this.stream, sy_f);
    Util.writeUnsignedNumber(this.stream, lt_f);
    Util.writeUnsignedNumber(this.stream, tot_f);
};
Dummy.prototype.encodeShift = function(sy_f, lt_f, shift) {
    this.<span class="apidocCodeKeywordSpan">encodeFreq</span>(sy_f, lt_f, 1 &lt;&lt; shift);
};
Dummy.prototype.encodeFinish = function() {
    return 0;
};
Dummy.prototype.decodeStart = function(skipInitialRead) {
    return skipInitialRead ? 0 : this.stream.readByte();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.encodeShift" id="apidoc.element.compressjs.RangeCoder.prototype.encodeShift">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeShift
        <span class="apidocSignatureSpan">(sy_f, lt_f, shift)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeShift = function (sy_f, lt_f, shift) {
    enc_normalize(this, this.stream);
    var r = this.range &gt;&gt;&gt; shift;
    var tmp = r * lt_f;
    this.low += tmp;
    if ((lt_f + sy_f) &gt;&gt;&gt; shift) {
        this.range -= tmp;
    } else {
        this.range = r * sy_f;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.encodeShort" id="apidoc.element.compressjs.RangeCoder.prototype.encodeShort">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeShort
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeShort = function (s) {
    this.encodeShift(1, s, 16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.encodeStart" id="apidoc.element.compressjs.RangeCoder.prototype.encodeStart">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>encodeStart
        <span class="apidocSignatureSpan">(c, initlength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeStart = function (c, initlength) {
    this.low = 0;
    this.range = Top_value;
    this.buffer = c;
    this.help = 0;
    this.bytecount = initlength;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.readBit" id="apidoc.element.compressjs.RangeCoder.prototype.readBit">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>readBit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBit = function () {
    var tmp = this.decodeCulShift(1);
    this.decodeUpdate(1, tmp, 1&lt;&lt;1);
    return tmp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.readByte" id="apidoc.element.compressjs.RangeCoder.prototype.readByte">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>readByte
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readByte = function () {
    var tmp = this.decodeCulShift(8);
    this.decodeUpdate(1, tmp, 1&lt;&lt;8);
    return tmp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.stream.writeByte(b);
};
Dummy.prototype._write16 = function(s) {
    this.stream.writeByte((s &gt;&gt;&gt; 8) &amp; 0xFF);
    this.stream.writeByte(s &amp; 0xFF);
};
Dummy.prototype._read8 = function() {
    return this.stream.<span class="apidocCodeKeywordSpan">readByte</span>();
};
Dummy.prototype._read16 = function() {
    var hi = this.stream.readByte();
    var lo = this.stream.readByte();
    return (hi&lt;&lt;8) | lo;
};
Dummy.prototype.encodeStart = function(c, initlength) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.writeBit" id="apidoc.element.compressjs.RangeCoder.prototype.writeBit">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>writeBit
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBit = function (b) {
    this.encodeShift(1, b?1:0, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.RangeCoder.prototype.writeByte" id="apidoc.element.compressjs.RangeCoder.prototype.writeByte">
        function <span class="apidocSignatureSpan">compressjs.RangeCoder.prototype.</span>writeByte
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeByte = function (b) {
    this.encodeShift(1, b, 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
define(['./RangeCoder','./Util'],function(RangeCoder,Util){
var Dummy = function(stream) {
    RangeCoder.call(this, stream);
};
Dummy.prototype = Object.create(RangeCoder.prototype);
Dummy.prototype._write8 = function(b) {
    Util.writeUnsignedNumber(this.stream, b);
    this.stream.<span class="apidocCodeKeywordSpan">writeByte</span>(b);
};
Dummy.prototype._write16 = function(s) {
    this.stream.writeByte((s &gt;&gt;&gt; 8) &amp; 0xFF);
    this.stream.writeByte(s &amp; 0xFF);
};
Dummy.prototype._read8 = function() {
    return this.stream.readByte();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.Simple" id="apidoc.module.compressjs.Simple">module compressjs.Simple</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.Simple.compressFile" id="apidoc.element.compressjs.Simple.compressFile">
        function <span class="apidocSignatureSpan">compressjs.Simple.</span>compressFile
        <span class="apidocSignatureSpan">(inStream, outStream, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFile = function (inStream, outStream, props) {
    inStream = Util.coerceInputStream(inStream);
    var o = Util.coerceOutputStream(outStream, outStream);
    outStream = o.stream;

    // write the magic number to identify this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        outStream.writeByte(magic.charCodeAt(i));
    }

    // if we know the size, write it
    var fileSize;
    if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
        fileSize = inStream.size;
    } else {
        fileSize = -1; // size unknown
    }
    if (suppressFinalByte) {
        var tmpOutput = Util.coerceOutputStream([]);
        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
        tmpOutput = tmpOutput.retval;
        for (i=0; i&lt;tmpOutput.length-1; i++) {
            outStream.writeByte(tmpOutput[i]);
        }
        suppressFinalByte = tmpOutput[tmpOutput.length-1];
    } else {
        Util.writeUnsignedNumber(outStream, fileSize + 1);
    }

    // call the guts to do the real compression
    guts(inStream, outStream, fileSize, props, suppressFinalByte);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the various options.

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.<span class="apidocCodeKeywordSpan">compressFile</span>(data);
var decompressed = algorithm.decompressFile(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Simple.decompressFile" id="apidoc.element.compressjs.Simple.decompressFile">
        function <span class="apidocSignatureSpan">compressjs.Simple.</span>decompressFile
        <span class="apidocSignatureSpan">(inStream, outStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFile = function (inStream, outStream) {
    inStream = Util.coerceInputStream(inStream);

    // read the magic number to confirm this file type
    // (it better be ASCII, we're not doing utf-8 conversion)
    var i;
    for (i=0; i&lt;magic.length; i++) {
        if (magic.charCodeAt(i) !== inStream.readByte()) {
            throw new Error("Bad magic");
        }
    }

    // read the file size &amp; create an appropriate output stream/buffer
    var fileSize = Util.readUnsignedNumber(inStream) - 1;
    var o = Util.coerceOutputStream(outStream, fileSize);
    outStream = o.stream;

    // call the guts to do the real decompression
    guts(inStream, outStream, fileSize);

    return o.retval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

From JavaScript:
```
var compressjs = require('compressjs');
var algorithm = compressjs.Lzp3;
var data = new Buffer('Example data', 'utf8');
var compressed = algorithm.compressFile(data);
var decompressed = algorithm.<span class="apidocCodeKeywordSpan">decompressFile</span>(compressed);
// convert from array back to string
var data2 = new Buffer(decompressed).toString('utf8');
console.log(data2);
```
There is a streaming interface as well.  Use `Uint8Array` or normal
JavaScript arrays when running in a browser.
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.Stream" id="apidoc.module.compressjs.Stream">module compressjs.Stream</a></h1>



</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.Stream.prototype" id="apidoc.module.compressjs.Stream.prototype">module compressjs.Stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.Stream.prototype.eof" id="apidoc.element.compressjs.Stream.prototype.eof">
        function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>eof
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eof = function () { return !!this._eof; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Stream.prototype.flush" id="apidoc.element.compressjs.Stream.prototype.flush">
        function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Stream.prototype.read" id="apidoc.element.compressjs.Stream.prototype.read">
        function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>read
        <span class="apidocSignatureSpan">(buf, bufOffset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (buf, bufOffset, length) {
    var ch, bytesRead = 0;
    while (bytesRead &lt; length) {
        ch = this.readByte();
        if (ch === EOF) { this._eof = true; break; }
        buf[bufOffset+(bytesRead++)] = ch;
    }
    return bytesRead;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Stream.prototype.readByte" id="apidoc.element.compressjs.Stream.prototype.readByte">
        function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>readByte
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readByte = function () {
    var buf = [ 0 ];
    var len = this.read(buf, 0, 1);
    if (len===0) { this._eof = true; return EOF; }
    return buf[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.stream.writeByte(b);
};
Dummy.prototype._write16 = function(s) {
    this.stream.writeByte((s &gt;&gt;&gt; 8) &amp; 0xFF);
    this.stream.writeByte(s &amp; 0xFF);
};
Dummy.prototype._read8 = function() {
    return this.stream.<span class="apidocCodeKeywordSpan">readByte</span>();
};
Dummy.prototype._read16 = function() {
    var hi = this.stream.readByte();
    var lo = this.stream.readByte();
    return (hi&lt;&lt;8) | lo;
};
Dummy.prototype.encodeStart = function(c, initlength) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Stream.prototype.seek" id="apidoc.element.compressjs.Stream.prototype.seek">
        function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>seek
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seek = function (pos) {
    throw new Error('Stream is not seekable.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var ch = s.readByte();
        if (ch === EOF) { this._eof = true; }
        return ch;
    };
    if ('size' in s) { input.size = s.size; }
    if ('seek' in s) {
        input.seek = function(pos) {
            s.<span class="apidocCodeKeywordSpan">seek</span>(pos); // may throw if s doesn't implement seek
            this._eof = false;
        };
    }
    if ('tell' in s) {
        input.tell = s.tell.bind(s);
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Stream.prototype.tell" id="apidoc.element.compressjs.Stream.prototype.tell">
        function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>tell
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tell = function () {
    throw new Error('Stream is not seekable.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Stream.prototype.write" id="apidoc.element.compressjs.Stream.prototype.write">
        function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>write
        <span class="apidocSignatureSpan">(buf, bufOffset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (buf, bufOffset, length) {
    var i;
    for (i=0; i&lt;length; i++) {
        this.writeByte(buf[bufOffset + i]);
    }
    return length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Stream.prototype.writeByte" id="apidoc.element.compressjs.Stream.prototype.writeByte">
        function <span class="apidocSignatureSpan">compressjs.Stream.prototype.</span>writeByte
        <span class="apidocSignatureSpan">(_byte)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeByte = function (_byte) {
    var buf = [ _byte ];
    this.write(buf, 0, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
define(['./RangeCoder','./Util'],function(RangeCoder,Util){
var Dummy = function(stream) {
    RangeCoder.call(this, stream);
};
Dummy.prototype = Object.create(RangeCoder.prototype);
Dummy.prototype._write8 = function(b) {
    Util.writeUnsignedNumber(this.stream, b);
    this.stream.<span class="apidocCodeKeywordSpan">writeByte</span>(b);
};
Dummy.prototype._write16 = function(s) {
    this.stream.writeByte((s &gt;&gt;&gt; 8) &amp; 0xFF);
    this.stream.writeByte(s &amp; 0xFF);
};
Dummy.prototype._read8 = function() {
    return this.stream.readByte();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.compressjs.Util" id="apidoc.module.compressjs.Util">module compressjs.Util</a></h1>


    <h2>
        <a href="#apidoc.element.compressjs.Util.arraycopy" id="apidoc.element.compressjs.Util.arraycopy">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>arraycopy
        <span class="apidocSignatureSpan">(dst, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arraycopy = function (dst, src) {
    console.assert(dst.length &gt;= src.length);
    for (var i = 0, len = src.length; i &lt; len ; i++) {
        dst[i] = src[i];
    }
    return dst;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
if (typeof define !== 'function') { var define = require('amdefine')(module); }
define(['./Util'], function(Util) {

/**
 * A static CRC lookup table
 */
  var crc32Lookup = Util.<span class="apidocCodeKeywordSpan">arraycopy</span>(Util.makeU32Buffer(256), [
  0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
  0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
  0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
  0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
  0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
  0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
  0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.coerceInputStream" id="apidoc.element.compressjs.Util.coerceInputStream">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>coerceInputStream
        <span class="apidocSignatureSpan">(input, forceRead)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coerceInputStream = function (input, forceRead) {
    if (!('readByte' in input)) {
        var buffer = input;
        input = new Stream();
        input.size = buffer.length;
        input.pos = 0;
        input.readByte = function() {
            if (this.pos &gt;= this.size) { return EOF; }
            return buffer[this.pos++];
        };
        input.read = function(buf, bufOffset, length) {
            var bytesRead = 0;
            while (bytesRead &lt; length &amp;&amp; this.pos &lt; buffer.length) {
                buf[bufOffset++] = buffer[this.pos++];
                bytesRead++;
            }
            return bytesRead;
        };
        input.seek = function(pos) { this.pos = pos; };
        input.tell = function() { return this.pos; };
        input.eof = function() { return this.pos &gt;= buffer.length; };
    } else if (forceRead &amp;&amp; !('read' in input)) {
        // wrap input if it doesn't implement read
        var s = input;
        input = new Stream();
        input.readByte = function() {
            var ch = s.readByte();
            if (ch === EOF) { this._eof = true; }
            return ch;
        };
        if ('size' in s) { input.size = s.size; }
        if ('seek' in s) {
            input.seek = function(pos) {
                s.seek(pos); // may throw if s doesn't implement seek
                this._eof = false;
            };
        }
        if ('tell' in s) {
            input.tell = s.tell.bind(s);
        }
    }
    return input;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
get: r.stream.getBuffer.bind(r.stream)
        });
        return r;
    };

    Util.compressFileHelper = function(magic, guts, suppressFinalByte) {
        return function(inStream, outStream, props) {
inStream = Util.<span class="apidocCodeKeywordSpan">coerceInputStream</span>(inStream);
var o = Util.coerceOutputStream(outStream, outStream);
outStream = o.stream;

// write the magic number to identify this file type
// (it better be ASCII, we're not doing utf-8 conversion)
var i;
for (i=0; i&lt;magic.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.coerceOutputStream" id="apidoc.element.compressjs.Util.coerceOutputStream">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>coerceOutputStream
        <span class="apidocSignatureSpan">(output, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coerceOutputStream = function (output, size) {
    var r = { stream: output, retval: output };
    if (output) {
        if (typeof(output)==='object' &amp;&amp; 'writeByte' in output) {
            return r;<span class="apidocCodeCommentSpan"> /* leave output alone */
</span>        } else if (typeof(size) === 'number') {
            console.assert(size &gt;= 0);
            r.stream = new BufferStream(Util.makeU8Buffer(size), false);
        } else { // output is a buffer
            r.stream = new BufferStream(output, false);
        }
    } else {
        r.stream = new BufferStream(Util.makeU8Buffer(16384), true);
    }
    Object.defineProperty(r, 'retval', {
        get: r.stream.getBuffer.bind(r.stream)
    });
    return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        });
        return r;
    };

    Util.compressFileHelper = function(magic, guts, suppressFinalByte) {
        return function(inStream, outStream, props) {
inStream = Util.coerceInputStream(inStream);
var o = Util.<span class="apidocCodeKeywordSpan">coerceOutputStream</span>(outStream, outStream);
outStream = o.stream;

// write the magic number to identify this file type
// (it better be ASCII, we're not doing utf-8 conversion)
var i;
for (i=0; i&lt;magic.length; i++) {
    outStream.writeByte(magic.charCodeAt(i));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.compressFileHelper" id="apidoc.element.compressjs.Util.compressFileHelper">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>compressFileHelper
        <span class="apidocSignatureSpan">(magic, guts, suppressFinalByte)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressFileHelper = function (magic, guts, suppressFinalByte) {
    return function(inStream, outStream, props) {
        inStream = Util.coerceInputStream(inStream);
        var o = Util.coerceOutputStream(outStream, outStream);
        outStream = o.stream;

        // write the magic number to identify this file type
        // (it better be ASCII, we're not doing utf-8 conversion)
        var i;
        for (i=0; i&lt;magic.length; i++) {
            outStream.writeByte(magic.charCodeAt(i));
        }

        // if we know the size, write it
        var fileSize;
        if ('size' in inStream &amp;&amp; inStream.size &gt;= 0) {
            fileSize = inStream.size;
        } else {
            fileSize = -1; // size unknown
        }
        if (suppressFinalByte) {
            var tmpOutput = Util.coerceOutputStream([]);
            Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
            tmpOutput = tmpOutput.retval;
            for (i=0; i&lt;tmpOutput.length-1; i++) {
                outStream.writeByte(tmpOutput[i]);
            }
            suppressFinalByte = tmpOutput[tmpOutput.length-1];
        } else {
            Util.writeUnsignedNumber(outStream, fileSize + 1);
        }

        // call the guts to do the real compression
        guts(inStream, outStream, fileSize, props, suppressFinalByte);

        return o.retval;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.compressWithModel" id="apidoc.element.compressjs.Util.compressWithModel">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>compressWithModel
        <span class="apidocSignatureSpan">(inStream, fileSize, model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compressWithModel = function (inStream, fileSize, model) {
    var inSize = 0;
    while (inSize !== fileSize) {
        var ch = inStream.readByte();
        if (ch === EOF) {
            model.encode(256); // end of stream;
            break;
        }
        model.encode(ch);
        inSize++;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.decompressFileHelper" id="apidoc.element.compressjs.Util.decompressFileHelper">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>decompressFileHelper
        <span class="apidocSignatureSpan">(magic, guts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressFileHelper = function (magic, guts) {
    return function(inStream, outStream) {
        inStream = Util.coerceInputStream(inStream);

        // read the magic number to confirm this file type
        // (it better be ASCII, we're not doing utf-8 conversion)
        var i;
        for (i=0; i&lt;magic.length; i++) {
            if (magic.charCodeAt(i) !== inStream.readByte()) {
                throw new Error("Bad magic");
            }
        }

        // read the file size &amp; create an appropriate output stream/buffer
        var fileSize = Util.readUnsignedNumber(inStream) - 1;
        var o = Util.coerceOutputStream(outStream, fileSize);
        outStream = o.stream;

        // call the guts to do the real decompression
        guts(inStream, outStream, fileSize);

        return o.retval;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.decompressWithModel" id="apidoc.element.compressjs.Util.decompressWithModel">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>decompressWithModel
        <span class="apidocSignatureSpan">(outStream, fileSize, model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompressWithModel = function (outStream, fileSize, model) {
    var outSize = 0;
    while (outSize !== fileSize) {
        var ch = model.decode();
        if (ch === 256) {
            break; // end of stream;
        }
        outStream.writeByte(ch);
        outSize++;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.fls" id="apidoc.element.compressjs.Util.fls">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>fls
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fls = function (v) {
    console.assert(v&gt;=0);
    if (v &gt; 0xFFFFFFFF) { // use floating-point mojo
        return 32 + fls(Math.floor(v / 0x100000000));
    }
    if ( (v &amp; 0xFFFF0000) !== 0) {
        if ( (v &amp; 0xFF000000) !== 0) {
            return 24 + bytemsb[(v&gt;&gt;&gt;24) &amp; 0xFF];
        } else {
            return 16 + bytemsb[v&gt;&gt;&gt;16];
        }
    } else if ( (v &amp; 0x0000FF00) !== 0) {
        return 8 + bytemsb[v&gt;&gt;&gt;8];
    } else {
        return bytemsb[v];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// lengthBitsModelFactory will be called with arguments 2, 4, 8, 16, etc
// and must return an appropriate model or coder.
var DeflateDistanceModel = function(size, extraStates,
                                    lgDistanceModelFactory,
                                    lengthBitsModelFactory) {
    var i;
    var bits = Util.<span class="apidocCodeKeywordSpan">fls</span>(size-1);
    this.extraStates = +extraStates || 0;
    this.lgDistanceModel = lgDistanceModelFactory(2*bits + extraStates);
    // this.distanceModel[n] used for distances which are n-bits long,
    // but only n-2 bits are encoded: the top bit is known to be one,
    // and the next bit is encoded by the lgDistanceModel.
    this.distanceModel = [];
    for (i=3 ; i &lt;= bits; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.log2c" id="apidoc.element.compressjs.Util.log2c">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>log2c
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log2c = function (v) {
    return (v===0)?-1:fls(v-1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.makeS32Buffer" id="apidoc.element.compressjs.Util.makeS32Buffer">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>makeS32Buffer
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeS32Buffer = function (size) {
    // Int32Array ought to be  automatically zero-filled
    return ensureZeroed(new Int32Array(size));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.makeU16Buffer" id="apidoc.element.compressjs.Util.makeU16Buffer">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>makeU16Buffer
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeU16Buffer = function (size) {
    // Uint16Array ought to be  automatically zero-filled
    return ensureZeroed(new Uint16Array(size));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.makeU32Buffer" id="apidoc.element.compressjs.Util.makeU32Buffer">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>makeU32Buffer
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeU32Buffer = function (size) {
    // Uint32Array ought to be  automatically zero-filled
    return ensureZeroed(new Uint32Array(size));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
if (typeof define !== 'function') { var define = require('amdefine')(module); }
define(['./Util'], function(Util) {

/**
 * A static CRC lookup table
 */
  var crc32Lookup = Util.arraycopy(Util.<span class="apidocCodeKeywordSpan">makeU32Buffer</span>(256), [
  0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
  0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
  0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
  0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
  0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
  0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
  0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.makeU8Buffer" id="apidoc.element.compressjs.Util.makeU8Buffer">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>makeU8Buffer
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeU8Buffer = function (size) {
    // Uint8Array ought to be  automatically zero-filled
    return ensureZeroed(new Uint8Array(size));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.buffer = buffer;
    this.resizeOk = resizeOk;
    this.pos = 0;
};
BufferStream.prototype = Object.create(Stream.prototype);
BufferStream.prototype.writeByte = function(_byte) {
    if (this.resizeOk &amp;&amp; this.pos &gt;= this.buffer.length) {
        var newBuffer = Util.<span class="apidocCodeKeywordSpan">makeU8Buffer</span>(this.buffer.length * 2);
        newBuffer.set(this.buffer);
        this.buffer = newBuffer;
    }
    this.buffer[this.pos++] = _byte;
};
BufferStream.prototype.getBuffer = function() {
    // trim buffer if needed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.readUnsignedNumber" id="apidoc.element.compressjs.Util.readUnsignedNumber">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>readUnsignedNumber
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUnsignedNumber = function (input) {
    var n = 0, c;
    while (true) {
        c = input.readByte();
        if (c&amp;0x80) { n += (c&amp;0x7F); break; }
        // using + and * instead of &lt;&lt; allows decoding numbers up to 2^53
        n = (n + c) * 128;
    }
    return n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return 0;
};
Dummy.prototype.decodeStart = function(skipInitialRead) {
    return skipInitialRead ? 0 : this.stream.readByte();
};
Dummy.prototype.decodeCulFreq = function(tot_f) {
    console.assert(tot_f &gt; 0);
    this.sy_f = Util.<span class="apidocCodeKeywordSpan">readUnsignedNumber</span>(this.stream);
    this.lt_f = Util.readUnsignedNumber(this.stream);
    this.tot_f= Util.readUnsignedNumber(this.stream);
    if (tot_f !== this.tot_f) {
        console.error('decodeCul* wrong total: got', tot_f,
                      'expected', this.tot_f);
    }
    return (this.sy_f&gt;&gt;&gt;1) + this.lt_f;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.compressjs.Util.writeUnsignedNumber" id="apidoc.element.compressjs.Util.writeUnsignedNumber">
        function <span class="apidocSignatureSpan">compressjs.Util.</span>writeUnsignedNumber
        <span class="apidocSignatureSpan">(output, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUnsignedNumber = function (output, n) {
    console.assert(n &gt;= 0);
    var bytes = [], i;
    do {
        bytes.push(n &amp; 0x7F);
        // use division instead of shift to allow encoding numbers up to
        // 2^53
        n = Math.floor( n / 128 );
    } while (n !== 0);
    bytes[0] |= 0x80; // mark end of encoding.
    for (i=bytes.length-1; i&gt;=0; i--) {
        output.writeByte(bytes[i]); // write in big-endian order
    }
    return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof define !== 'function') { var define = require('amdefine')(module); }
define(['./RangeCoder','./Util'],function(RangeCoder,Util){
var Dummy = function(stream) {
    RangeCoder.call(this, stream);
};
Dummy.prototype = Object.create(RangeCoder.prototype);
Dummy.prototype._write8 = function(b) {
    Util.<span class="apidocCodeKeywordSpan">writeUnsignedNumber</span>(this.stream, b);
    this.stream.writeByte(b);
};
Dummy.prototype._write16 = function(s) {
    this.stream.writeByte((s &gt;&gt;&gt; 8) &amp; 0xFF);
    this.stream.writeByte(s &amp; 0xFF);
};
Dummy.prototype._read8 = function() {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>